<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat App Mockup V44 - Channel Roles</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* === CSS СТИЛИ (V44 - Channel Roles) === */
        :root {
            /* Общие цвета */
            --color-brand: #53a3f5; 
            --color-accent: #34c759; 
            --color-light-blue: #53a3f51a; 
            
            /* Темная тема - Стиль Telegram Desktop */
            --bg-body: #17212b; 
            --bg-app: #17212b; 
            --bg-sidebar: #0e1621; 
            --bg-input: #232e3a; 
            --text-primary: #ffffff; 
            --text-secondary: #8c9096; 
            --border-light: #242f3e; 
            --bubble-sent: #53a3f5; 
            --bubble-received: #242f3e; 
            --sidebar-width: 320px;
        }

        /* --- ОБЩИЕ СТИЛИ И ТИПОГРАФИКА --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center; 
            overflow: hidden; 
        }

        .container {
            width: 90%;
            max-width: 1400px; 
            height: 90vh; 
            min-height: 600px;
            display: flex;
            background-color: var(--bg-app);
            border-radius: 10px; 
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4); 
            overflow: hidden;
        }

        .hidden { display: none !important; }

        /* Анимации */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .message-bubble { animation: fadeInUp 0.3s ease-out; }

        /* --- АУТЕНТИФИКАЦИЯ И МОДАЛЬНЫЕ ОКНА --- */
        .auth-card {
            background-color: var(--bg-input);
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
            animation: fadeIn 0.5s ease-out;
        }
        .auth-card h2 { margin-bottom: 25px; font-weight: 500; }
        .auth-card .switch-link { color: var(--color-brand); cursor: pointer; margin-top: 15px; display: block; font-size: 0.9em; }

        /* Стили для всех модальных окон */
        .permission-modal {
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 50; 
            overflow-y: auto; /* Для длинных списков в модальном окне */
        }
        /* Модальное окно по умолчанию должно быть скрыто с помощью flex */
        .modal-container:not(.hidden) { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
        }
        
        .modal-content {
            background-color: var(--bg-input);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
            width: 400px;
            max-width: 90%;
            max-height: 90vh; 
            overflow-y: auto;
        }


        /* --- КНОПКИ И ИНПУТЫ --- */
        button {
            border: none;
            cursor: pointer;
            font-weight: 500;
            padding: 12px 25px;
            border-radius: 8px; 
            background-color: var(--color-brand);
            color: white;
            transition: background-color 0.2s, transform 0.1s;
        }
        button:hover { background-color: #4a91db; }
        button:active { transform: scale(0.98); }
        
        input, textarea {
            border: 1px solid var(--border-light); 
            border-radius: 8px; 
            background-color: var(--bg-input);
            padding: 12px 15px;
            margin-bottom: 12px;
            color: var(--text-primary);
            outline: none;
            width: 100%;
        }
        input:focus, textarea:focus {
            border-color: var(--color-brand); 
            box-shadow: 0 0 0 1px var(--color-brand);
        }
        
        /* --- AVATARS И БЕЙДЖИКИ (ROUND) --- */
        .avatar {
            width: 45px; height: 45px; line-height: 45px;
            border-radius: 50%; 
            text-align: center;
            font-weight: 500;
            font-size: 1.1em;
            flex-shrink: 0;
            background-size: cover !important;
            background-position: center !important;
            color: #fff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .chat-avatar-large { 
            width: 50px; height: 50px; line-height: 50px; 
            border-radius: 50%; 
        }
        .profile-avatar-large { 
            width: 96px; height: 96px; line-height: 96px; 
            margin: 0 auto 20px; 
            border-radius: 50%; 
        }

        .verified-badge { color: var(--color-brand); font-size: 0.8em; margin-left: 4px; }
        .channel-badge { background-color: #53a3f550; color: var(--color-brand); font-size: 0.7em; padding: 2px 5px; border-radius: 5px; margin-left: 5px; font-weight: 400; }

        /* --- SIDEBAR И СПИСОК ЧАТОВ --- */
        .chats-sidebar {
            width: var(--sidebar-width);
            min-width: var(--sidebar-width);
            background-color: var(--bg-sidebar);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-light);
            padding: 0;
            flex-shrink: 0;
        }
        
        .sidebar-header {
            padding: 10px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: var(--bg-input); 
            border-bottom: 1px solid var(--border-light);
        }
        .search-bar { flex-grow: 1; }
        .search-bar input { 
            margin: 0; 
            padding: 8px 12px; 
            border-radius: 18px; 
            font-size: 0.9em; 
            border: none; 
            background-color: #313f4d; 
            color: var(--text-primary); 
        }
        .search-bar input:focus { box-shadow: 0 0 0 1px var(--color-brand); }
        .action-icon-small { font-size: 1.1em; color: var(--text-secondary); cursor: pointer; padding: 5px; }
        .settings-icon { 
            font-size: 1.2em; 
            color: var(--text-secondary); 
            cursor: pointer; 
            padding: 5px;
            transition: color 0.2s;
        }
        .settings-icon:hover { color: var(--color-brand); }

        
        .chat-item {
            padding: 10px 15px; 
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.15s;
            border-bottom: 1px solid var(--border-light);
        }
        
        .chat-item:hover { background-color: #17212b; }

        .chat-item.active {
            background-color: var(--color-light-blue);
        }
        
        .chat-item .info {
            flex-grow: 1;
            margin-left: 12px;
            overflow: hidden;
        }
        .chat-item .name { font-weight: 500; font-size: 1em; display: flex; align-items: center; }
        .chat-item .last-message { color: var(--text-secondary); font-size: 0.85em; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        .new-message-badge {
            background-color: var(--color-accent);
            color: white;
            min-width: 22px;
            height: 22px;
            border-radius: 11px;
            font-size: 0.8em;
            line-height: 22px;
            text-align: center;
            padding: 0 6px;
            font-weight: 700;
        }
        .chat-item .time { font-size: 0.8em; color: var(--text-secondary); margin-left: 8px; flex-shrink: 0;}

        /* --- CHAT WINDOW --- */
        .chat-window {
            flex-grow: 1;
            display: flex;
            flex-direction: column; 
            position: relative;
            overflow: hidden; 
        }
        
        .chat-header { 
            padding: 10px 20px; 
            border-bottom: 1px solid var(--border-light);
            background-color: var(--bg-input);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0; 
        }
        .chat-header .info-group { display: flex; align-items: center; cursor: pointer; }
        .chat-header .status { color: var(--text-secondary); font-size: 0.9em; margin-top: 2px;}

        .messages-area { 
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px 20px;
            background-color: var(--bg-app);
            display: flex;
            flex-direction: column;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%2317212b"/><circle cx="50" cy="50" r="1" fill="%23242f3e" opacity="0.1"/></svg>'); 
        }
        .messages-area::-webkit-scrollbar { width: 8px; }
        .messages-area::-webkit-scrollbar-thumb { background-color: #313f4d; border-radius: 4px; }
        .messages-area::-webkit-scrollbar-track { background: var(--bg-app); }

        /* Сообщения */
        .message-bubble {
            max-width: 60%; 
            padding: 10px 14px;
            margin: 3px 0;
            border-radius: 18px;
            word-wrap: break-word;
            font-size: 0.95em;
            line-height: 1.4;
        }
        .message-bubble.sent {
            align-self: flex-end;
            background-color: var(--bubble-sent);
            color: white;
            border-bottom-right-radius: 6px;
        }
        .message-bubble.received {
            align-self: flex-start;
            background-color: var(--bubble-received);
            color: var(--text-primary);
            border-bottom-left-radius: 6px;
        }
        .message-bubble .time-stamp {
             font-size: 0.7em;
             color: #ffffff99;
             margin-top: 5px;
             float: right;
             margin-left: 10px;
             white-space: nowrap;
        }
        .message-bubble.received .time-stamp {
             color: var(--text-secondary);
        }
        
        /* Стили для голосового сообщения */
        .voice-message-container {
             display: flex;
             align-items: center;
             gap: 10px;
        }
        .voice-message-container button {
             width: 30px; height: 30px;
             padding: 0;
             border-radius: 50%;
             background-color: white;
             color: var(--bubble-sent); /* Цвет иконки для исходящего */
        }
        .message-bubble.received .voice-message-container button {
             color: var(--bubble-received); /* Цвет иконки для входящего */
             background-color: var(--color-brand);
        }
        .voice-message-container span {
             font-size: 0.9em;
             font-weight: 500;
        }
        
        /* Ввод сообщения (Footer) */
        .input-area {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            border-top: 1px solid var(--border-light);
            background-color: var(--bg-input);
            flex-shrink: 0; 
        }
        .input-area input {
            flex-grow: 1;
            margin: 0 10px 0 0;
            padding: 10px 15px;
            border-radius: 20px; 
            border: none;
            background-color: #313f4d;
        }
        .input-area button {
            width: 38px; height: 38px; 
            border-radius: 50%; 
            padding: 0;
            font-size: 1em;
            flex-shrink: 0;
        }
        
        /* --- PROFILE / SETTINGS VIEW --- */
        .profile-page {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: var(--bg-body);
            overflow-y: auto;
            transition: transform 0.3s ease-out;
            transform: translateX(100%);
            z-index: 10;
        }
        .profile-page.active-view {
             transform: translateX(0);
        }
        .profile-header {
             padding: 10px 15px; 
             display: flex; 
             align-items: center;
             border-bottom: 1px solid var(--border-light);
             background-color: var(--bg-input);
             flex-shrink: 0;
        }
        .profile-content {
             padding: 30px 20px;
             text-align: center;
        }
        .menu-list {
            list-style: none;
            padding: 0;
            margin: 30px 0;
            border-radius: 10px;
            overflow: hidden;
            background-color: var(--bg-input);
            text-align: left;
        }
        .menu-item {
            padding: 14px 15px;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light);
            transition: background-color 0.2s;
        }
        .menu-item:hover { background-color: #242f3e; }
        .menu-item i { margin-right: 15px; color: var(--color-brand); width: 20px; text-align: center; }
        .menu-item span { flex-grow: 1; font-weight: 400; }
        .menu-item:last-child { border-bottom: none; }
        .menu-item.logout { color: #e74c3c; }
        .menu-item.logout i { color: #e74c3c; }
        
        /* Стили для списка аккаунтов */
        #account-list .menu-item {
            display: grid;
            grid-template-columns: 45px 1fr 30px;
            gap: 10px;
            align-items: center;
        }
        #account-list .menu-item .avatar { margin: 0; }
        #account-list .menu-item .account-info { 
            display: flex; 
            flex-direction: column; 
            text-align: left;
        }
        #account-list .menu-item .account-info .name { 
            font-weight: 500; 
            font-size: 1em;
            display: flex;
            align-items: center;
        }
        #account-list .menu-item .account-info .at { 
            color: var(--text-secondary); 
            font-size: 0.85em;
        }
        #account-list .menu-item.current-user {
            background-color: var(--color-light-blue);
        }
        .add-account-btn {
            background-color: var(--bg-input);
            color: var(--color-brand);
            border-top: 1px solid var(--border-light);
            width: 100%;
            border-radius: 0 0 10px 10px;
            padding: 10px;
            margin-top: -1px;
            font-weight: 500;
        }
        
        /* Кнопка сброса (новые стили) */
        .reset-button {
            background-color: #e74c3c;
            color: white;
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 0.9em;
            margin-top: 10px;
        }
        
        /* Стили для Админ Панели */
        .admin-action-item {
             border: 1px solid var(--border-light); 
             padding: 15px; 
             border-radius: 8px; 
             margin-bottom: 20px;
             text-align: left;
        }
        .admin-action-item button { margin-top: 8px; }
        
        /* Стили для списка подписчиков (в модальном окне) */
        .subscriber-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-light);
        }
        .subscriber-item:last-child {
            border-bottom: none;
        }
        .subscriber-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .subscriber-info .name {
            font-weight: 500;
        }
        .subscriber-role-badge {
            background-color: #e67e22;
            color: white;
            font-size: 0.7em;
            padding: 2px 5px;
            border-radius: 5px;
            margin-left: 5px;
        }
        .subscriber-actions button {
            padding: 5px 10px;
            font-size: 0.8em;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    
    <div class="auth-container" id="auth-view" style="position: absolute; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 20;">
        <div class="auth-card">
            <i class="fas fa-paper-plane" style="font-size: 3rem; color: var(--color-brand); margin-bottom: 25px;"></i>
            <h2 id="auth-title">Создание аккаунта</h2>
            <div class="error-message" id="error-message" style="color: #e74c3c; margin-bottom: 10px;"></div>
            <form id="auth-form" style="display: flex; flex-direction: column;">
                <input type="text" id="auth-name" name="name" placeholder="Имя" required>
                <input type="text" id="auth-username" name="username" placeholder="Username (@user)" required pattern="^@[a-zA-Z0-9_]{5,}$">
                <input type="email" id="auth-email" name="email" placeholder="Email" required>
                <input type="password" id="auth-password" name="password" placeholder="Пароль" required>
                <button type="submit" id="auth-submit-btn" style="margin-top: 10px;">Зарегистрироваться</button>
            </form>
            <span class="switch-link" onclick="switchAuthMode()">Уже есть аккаунт? Войти</span>
            
            <button type="button" onclick="showAdminLoginModal()" style="margin-top: 15px; background-color: #e74c3c; width: 100%;">
                Войти в Админ-Аккаунт
            </button>
            
             <button class="reset-button" onclick="resetAllData()">Сбросить Все Данные</button>
        </div>
    </div>

    <div class="container hidden" id="messenger-view">
        
        <aside class="chats-sidebar">
            <div class="sidebar-header">
                <div id="sidebar-profile-avatar" class="avatar" style="cursor: pointer;" onclick="showProfile(true)">Я</div>
                <div class="search-bar">
                    <input type="text" id="search-friend-input" placeholder="Поиск" onkeydown="handleSearchKey(event)">
                </div>
                <i class="fas fa-plus action-icon-small" onclick="showSearchModal()" title="Найти"></i>
                <i class="fas fa-bullhorn action-icon-small" onclick="showCreateChannelModal()" title="Создать Канал"></i>
                <i class="fas fa-cog settings-icon" onclick="showProfile(true)" title="Настройки"></i> 
            </div>
            
            <div id="chats-list-container" style="overflow-y: auto; flex-grow: 1;">
                </div>
        </aside>

        <main class="chat-window" id="main-content">
            
            <div id="chat-view" style="width: 100%; height: 100%; display: flex; flex-direction: column;">
                <header class="chat-header">
                    <div class="info-group" onclick="alert('Просмотр профиля чата')">
                        <div class="avatar chat-avatar-large" id="current-chat-avatar"></div>
                        <div style="margin-left: 15px;">
                            <span class="name" id="current-chat-name" style="display: block; font-size: 1.1em;">Выберите чат</span>
                            <span class="status" id="current-chat-status"></span>
                        </div>
                    </div>
                    <div class="action-icons">
                        <button id="channel-subscribe-btn" class="hidden" style="padding: 5px 10px; font-size: 0.85em; border-radius: 15px;"></button>
                        <i id="channel-settings-icon" class="fas fa-cog action-icon-small hidden" style="margin-left: 15px;" onclick="showChannelSettings()"></i>
                        <i class="fas fa-search action-icon-small" style="margin-left: 15px;" onclick="alert('Поиск в чате')"></i>
                        <i class="fas fa-ellipsis-v action-icon-small"></i>
                    </div>
                </header>

                <div class="messages-area" id="messages-area" oncontextmenu="handleRightClick(event)">
                    <div style="text-align: center; color: var(--text-secondary); margin-top: 20px;">
                        <i class="fas fa-comments" style="font-size: 3em; margin-bottom: 10px; color: var(--border-light);"></i>
                        <p>Начните новый чат или выберите канал.</p>
                    </div>
                </div>

                <div id="reply-preview" class="hidden" style="display: flex; align-items: center; padding: 10px 15px; background-color: #242f3e; border-top: 1px solid var(--border-light);">
                    <div class="reply-to-content" style="border-left: 3px solid var(--color-accent); flex-grow: 1; padding: 0 10px;">
                        <span class="reply-sender" id="reply-preview-sender" style="color: var(--color-brand); font-size: 0.8em; font-weight: 500;"></span>
                        <span style="display: block; color: var(--text-primary); font-size: 0.9em; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;" id="reply-preview-text"></span>
                    </div>
                    <i class="fas fa-times" style="cursor: pointer; margin-left: 10px; color: var(--text-secondary);" onclick="cancelReply()"></i>
                </div>

                <footer class="input-area" id="chat-input-area">
                    <label for="image-upload-input" style="font-size: 1.2em; color: var(--text-secondary); cursor: pointer; padding: 5px 10px;">
                        <i class="fas fa-paper-clip"></i>
                    </label>
                    <input type="file" id="image-upload-input" accept="image/*" class="hidden" onchange="previewImage(event)">

                    <input type="text" id="message-input" placeholder="Написать сообщение..." onkeydown="handleMessageKey(event)">
                    
                    <button class="send-button" id="send-voice-btn" onclick="handleSendOrVoice()">
                        <i class="fas fa-microphone" id="send-voice-icon"></i>
                    </button>
                </footer>
            </div>
            
            <div id="profile-view" class="profile-page">
                
                <header class="profile-header">
                    <i class="fas fa-arrow-left" style="color: var(--color-brand); font-size: 1.2em; cursor: pointer;" onclick="hideProfile()"></i>
                    <h2 style="margin-left: 20px; font-size: 1.2em; font-weight: 500;">Настройки Аккаунта</h2>
                </header>

                <div class="profile-content">
                    <div class="avatar profile-avatar-large" id="profile-avatar-display">Я</div>
                    <h3 id="profile-name-display" style="font-weight: 500; margin-bottom: 5px; display: flex; align-items: center; justify-content: center;">Имя Пользователя</h3>
                    <p id="profile-at-display" style="color: var(--text-secondary); font-size: 0.9em; margin-bottom: 20px;">@username</p>
                    
                    <div id="edit-profile-area" class="profile-form-group hidden" style="margin-bottom: 20px;">
                        <h4 style="margin-bottom: 10px; font-weight: 400; color: var(--color-brand);">Редактирование</h4>
                        <form id="profile-form">
                            <input type="text" id="profile-name-input" placeholder="Имя" required>
                            <input type="text" id="profile-username-input" placeholder="Username (@user)" pattern="^@[a-zA-Z0-9_]{5,}$" required>
                            <input type="text" id="profile-status-input" placeholder="Статус (напр., Онлайн)">
                            <input type="text" id="profile-photo-input" placeholder="URL фото или #цвет">
                            <button type="submit" style="width: 100%;">Сохранить</button>
                        </form>
                    </div>

                    <h4 style="margin: 10px 0 10px; font-weight: 500; text-align: left; color: var(--text-secondary);">Аккаунты</h4>
                    <ul class="menu-list" id="account-list">
                         </ul>
                    <button class="add-account-btn" onclick="addAccount()">
                        <i class="fas fa-plus"></i> Добавить Аккаунт
                    </button>

                    <ul class="menu-list" style="margin-top: 20px;">
                        <li class="menu-item" onclick="toggleEditProfile()"> <i class="fas fa-user-edit"></i> <span>Редактировать Профиль</span> <i class="fas fa-chevron-right"></i> </li>
                        <li class="menu-item hidden" id="admin-menu-item" onclick="showAdminPanel()"> <i class="fas fa-shield-alt" style="color: #e74c3c;"></i> <span>Админ Панель</span> <i class="fas fa-chevron-right"></i> </li>
                        <li class="menu-item" onclick="alert('Информация о версии: V44 (Channel Roles)')"> <i class="fas fa-info-circle"></i> <span>О приложении (V44)</span> <i class="fas fa-chevron-right"></i> </li>
                        <li class="menu-item logout" onclick="logout()"> <i class="fas fa-sign-out-alt"></i> <span>Выйти из текущего аккаунта</span> <i class="fas fa-chevron-right"></i> </li>
                    </ul>

                    
                </div>
                
            </div>
            
            <div id="channel-settings-view" class="profile-page">
                
                <header class="profile-header">
                    <i class="fas fa-arrow-left" style="color: var(--color-brand); font-size: 1.2em; cursor: pointer;" onclick="hideChannelSettings()"></i>
                    <h2 style="margin-left: 20px; font-size: 1.2em; font-weight: 500;">Настройки Канала</h2>
                </header>

                <div class="profile-content">
                    <div class="avatar profile-avatar-large" id="channel-settings-avatar">К</div>
                    <h3 id="channel-settings-name" style="font-weight: 500; margin-bottom: 5px; display: flex; align-items: center; justify-content: center;">Название Канала</h3>
                    <p id="channel-settings-at" style="color: var(--text-secondary); font-size: 0.9em; margin-bottom: 20px;">@channel_at</p>
                    
                    <div class="profile-form-group" style="margin-bottom: 20px;">
                        <h4 style="margin-bottom: 10px; font-weight: 400; color: var(--color-brand);">Редактирование Канала</h4>
                        <form id="channel-settings-form">
                            <input type="text" id="channel-settings-name-input" placeholder="Название" required>
                            <input type="text" id="channel-settings-at-input" placeholder="Username (@channel)" pattern="^@[a-zA-Z0-9_]{5,}$" required>
                            <input type="text" id="channel-settings-photo-input" placeholder="URL фото или #цвет">
                            <button type="submit" style="width: 100%;">Сохранить Изменения</button>
                        </form>
                    </div>

                    <ul class="menu-list">
                        <li class="menu-item" onclick="showSubscribersModal()"> <i class="fas fa-users"></i> <span>Управление подписчиками</span> <i class="fas fa-chevron-right"></i> </li>
                        <li class="menu-item" onclick="alert('Загрузка файла...')"> <i class="fas fa-file-upload"></i> <span>Отправить файл</span> <i class="fas fa-chevron-right"></i> </li>
                        <li class="menu-item logout" onclick="deleteChannel()"> <i class="fas fa-trash-alt"></i> <span>Удалить Канал</span> <i class="fas fa-chevron-right"></i> </li>
                    </ul>

                    
                </div>
                
            </div>
            
            <div id="admin-panel" class="profile-page">
                <header class="profile-header">
                    <i class="fas fa-arrow-left" style="color: var(--color-brand); font-size: 1.2em; cursor: pointer;" onclick="hideAdminPanel()"></i>
                    <h2 style="margin-left: 20px; font-size: 1.4em; font-weight: 500; color: #e74c3c;">Админ Панель</h2>
                </header>
                <div class="profile-content" style="text-align: left;">
                    
                    <h3 style="margin-bottom: 15px; font-weight: 500; color: #e74c3c;"><i class="fas fa-shield-alt"></i> Управление Верификацией</h3>
                    <input type="text" id="admin-verify-input" placeholder="Введите @username пользователя/канала" onkeydown="if(event.key === 'Enter') adminSearchVerify()">
                    <button onclick="adminSearchVerify()" style="width: 100%; margin-bottom: 20px; padding: 10px; background-color: #3498db;">Поиск для Верификации</button>
                    <div id="admin-verify-result"></div>

                    <h3 style="margin-top: 30px; margin-bottom: 15px; font-weight: 500;">Управление пользователями</h3>
                    <input type="text" id="admin-search-user-input" placeholder="Поиск по @username" onkeydown="if(event.key === 'Enter') adminSearchUser()">
                    <button onclick="adminSearchUser()" style="width: 100%; margin-bottom: 20px; padding: 10px;">Поиск</button>
                    <div id="admin-search-result"></div>
                    
                    <h3 style="margin-top: 30px; margin-bottom: 15px; font-weight: 500;">Управление Каналами (Всего: <span id="admin-channel-count">0</span>)</h3>
                    <div id="admin-channel-list"></div>
                </div>
            </div>

        </main>
    </div>
    
    <div id="search-modal" class="permission-modal modal-container hidden" onclick="if(event.target.id === 'search-modal') hideSearchModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h3 style="font-weight: 500;">Найти собеседника/канал</h3>
            <input type="text" id="search-user-input" placeholder="Введите @username" onkeydown="if(event.key === 'Enter') performSearch()" style="margin-top: 15px;">
            <button onclick="performSearch()" style="width: 100%; margin-bottom: 15px; padding: 10px;">Поиск</button>
            <div id="search-result" style="text-align: left;"></div>
        </div>
    </div>
    
    <div id="create-channel-modal" class="permission-modal modal-container hidden" onclick="if(event.target.id === 'create-channel-modal') hideCreateChannelModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h3 style="font-weight: 500;">Создание Канала</h3>
            <div class="error-message" id="channel-error-message" style="color: #e74c3c; margin-bottom: 10px;"></div>
            <input type="text" id="channel-name-input" placeholder="Название Канала" required style="margin-top: 15px;">
            <input type="text" id="channel-at-input" placeholder="Username Канала (@mychannel)" required oninput="validateChannelAt()">
            <input type="text" id="channel-photo-input" placeholder="URL фото или #цвет">
            <button onclick="createChannel()" style="width: 100%; padding: 10px;">Создать Канал</button>
        </div>
    </div>
    
    <div id="voice-recording-modal" class="permission-modal modal-container hidden">
        <div class="modal-content" style="width: 300px; text-align: center;">
            <h3 id="voice-modal-title"><i class="fas fa-microphone-alt" style="color: #e74c3c;"></i> Идет запись...</h3>
            <div style="font-size: 3em; margin: 20px 0; color: var(--color-brand);" id="recording-timer">00:00</div>
            <div id="recording-actions" class="hidden" style="display: flex; gap: 10px;">
                 <button style="background-color: #2ecc71; flex-grow: 1; padding: 10px;" onclick="stopVoiceRecording(true)">Отправить</button>
                 <button style="background-color: #e67e22; flex-grow: 1; padding: 10px;" onclick="stopVoiceRecording(false)">Отмена</button>
            </div>
            <p id="voice-permissions-warning" style="color: var(--text-secondary); margin-top: 15px;">**СИМУЛЯЦИЯ:** Имитация записи...</p>
        </div>
    </div>
    
    <div id="context-menu" class="hidden" style="position: fixed; background-color: var(--bg-input); border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); z-index: 50; padding: 5px; min-width: 150px; animation: fadeIn 0.1s;">
        <div class="menu-item" style="padding: 10px; margin: 0; border: none; background: none;" onclick="replyToSelectedMessage()">
            <i class="fas fa-reply" style="color: var(--text-primary); margin-right: 10px;"></i> <span style="color: var(--text-primary);">Ответить</span>
        </div>
    </div>

    <div id="admin-login-modal" class="permission-modal modal-container hidden" onclick="if(event.target.id === 'admin-login-modal') hideAdminLoginModal()">
        <div class="modal-content" style="width: 300px;" onclick="event.stopPropagation()">
            <h3 style="font-weight: 500;">Вход в Админ-Аккаунт</h3>
            <p style="color: var(--text-secondary); margin-bottom: 15px;">Введите пароль для @durove</p>
            <div class="error-message" id="admin-login-error" style="color: #e74c3c; margin-bottom: 10px;"></div>
            <input type="password" id="admin-login-password" placeholder="Пароль" required onkeydown="if(event.key === 'Enter') attemptAdminLogin()">
            <button onclick="attemptAdminLogin()" style="width: 100%; padding: 10px;">Войти</button>
        </div>
    </div>
    
    <div id="admin-time-modal" class="permission-modal modal-container hidden" onclick="if(event.target.id === 'admin-time-modal') hideAdminTimeModal()">
        <div class="modal-content" style="width: 300px;" onclick="event.stopPropagation()">
            <h3 style="font-weight: 500;" id="admin-time-title">Установить срок</h3>
            <div class="error-message" id="admin-time-error" style="color: #e74c3c; margin-bottom: 10px;"></div>
            
            <p style="color: var(--text-secondary); margin-bottom: 10px;" id="admin-time-text">Введите количество дней:</p>
            
            <input type="number" id="admin-duration-input" placeholder="Количество дней (1-365)" min="1" max="365" required>
            
            <button onclick="executeAdminTimedAction()" style="width: 100%; padding: 10px;">Применить</button>
        </div>
    </div>
    
    <div id="subscribers-modal" class="permission-modal hidden" onclick="if(event.target.id === 'subscribers-modal') hideSubscribersModal()">
        <div class="modal-content" style="max-width: 500px;" onclick="event.stopPropagation()">
            <h3 style="font-weight: 500; margin-bottom: 15px;">Управление Подписчиками</h3>
            <div id="subscribers-list-container">
                </div>
            <button onclick="hideSubscribersModal()" style="margin-top: 20px; width: 100%; background-color: #95a5a6;">Закрыть</button>
        </div>
    </div>


    <script>
        // === JAVASCRIPT ЛОГИКА (V44 - Channel Roles) ===

        // --- ГЛОБАЛЬНЫЙ СТАТУС ---
        let AppState = {
            currentUserId: null,
            currentUser: {},
            currentChatId: null, 
            currentChatData: null, 
            isLoginMode: false, 
            pollingInterval: null,
            lastKnownMessagesHash: '', 
            replyMessageData: null, 
            currentImagePreview: null,
            isRecording: false, 
            voiceRecordingTimer: null,
            voiceDuration: 0,
            selectedMessageElement: null,
            adminTargetUser: null,
            adminTargetVerify: null,
            adminCurrentActionType: null // 'block' или 'freeze'
        };
        
        // --- КОНСТАНТЫ И ХРАНЕНИЕ ---
        const CONST = {
            ADMIN_USER_ID: 1000, 
            // Обновляем ключи, чтобы избежать конфликтов со старыми данными
            USERS_STORAGE_KEY: 'tgCloneUsersV9',
            AUTH_USER_IDS_KEY: 'tgCloneAuthUserIdsV9', 
            CURRENT_AUTH_ID_KEY: 'tgCloneCurrentAuthIdV9',
            CHAT_MESSAGES_PREFIX: 'tgCloneMessages_',
            FRIENDS_PREFIX: 'tgCloneFriends_',
            CHANNELS_STORAGE_KEY: 'tgCloneChannelsV9', 
            CHANNEL_SUBS_PREFIX: 'tgCloneChannelSubs_',
            CHANNEL_MESSAGES_PREFIX: 'tgCloneChannelMsgs_'
        };
        
        // --- StorageManager ---
        const StorageManager = {
            get(key) {
                const stored = localStorage.getItem(key);
                return stored ? JSON.parse(stored) : null;
            },
            set(key, data) {
                localStorage.setItem(key, JSON.stringify(data));
            },
            remove(key) {
                localStorage.removeItem(key);
            },
            
            // НОВЫЕ ФУНКЦИИ ДЛЯ МУЛЬТИ-АККАУНТОВ
            getAuthUserIds() { return this.get(CONST.AUTH_USER_IDS_KEY) || []; },
            saveAuthUserIds(ids) { this.set(CONST.AUTH_USER_IDS_KEY, ids); },
            getCurrentAuthId() { return this.get(CONST.CURRENT_AUTH_ID_KEY); },
            setCurrentAuthId(id) { this.set(CONST.CURRENT_AUTH_ID_KEY, id); },

            getAllUsers() { return this.get(CONST.USERS_STORAGE_KEY) || []; },
            saveAllUsers(users) { this.set(CONST.USERS_STORAGE_KEY, users); },
            getUserMessages(userId) { 
                return this.get(CONST.CHAT_MESSAGES_PREFIX + userId) || {}; 
            },
            saveUserMessages(data, userId) { this.set(CONST.CHAT_MESSAGES_PREFIX + userId, data); },
            getUserFriends(userId) { return this.get(CONST.FRIENDS_PREFIX + userId) || []; },
            saveUserFriends(friends, userId) { this.set(CONST.FRIENDS_PREFIX + userId, friends); },
            getAllChannels() { return this.get(CONST.CHANNELS_STORAGE_KEY) || []; },
            saveAllChannels(channels) { this.set(CONST.CHANNELS_STORAGE_KEY, channels); },
            getChannelSubscriptions(userId) { return this.get(CONST.CHANNEL_SUBS_PREFIX + userId) || []; },
            saveChannelSubscriptions(subscriptions, userId) { this.set(CONST.CHANNEL_SUBS_PREFIX + userId, subscriptions); },
            getChannelMessages(channelId) { return this.get(CONST.CHANNEL_MESSAGES_PREFIX + channelId) || []; },
            saveChannelMessages(messages, channelId) { this.set(CONST.CHANNEL_MESSAGES_PREFIX + channelId, messages); },
            
            // НОВАЯ ФУНКЦИЯ ДЛЯ АДМИНОВ
            getUserById(id) {
                return this.getAllUsers().find(u => u.id === id);
            }
        };

        // --- HELPER ФУНКЦИИ ---
        function generateAvatarColor(text) {
             if (!text) return '#7f8c8d';
             let hash = 0;
             for (let i = 0; i < text.length; i++) {
                 hash = text.charCodeAt(i) + ((hash << 5) - hash);
             }
             let color = '#';
             for (let i = 0; i < 3; i++) {
                 let value = (hash >> (i * 8)) & 0xFF;
                 color += ('00' + value.toString(16)).substr(-2);
             }
             return color;
        }

        function renderAvatar(photo, name, sizeClass = 'avatar') {
             let content = '';
             let style = '';
             const displayChar = name ? name[0] : '?';
             const finalColor = photo && photo.startsWith('#') ? photo : generateAvatarColor(name || 'Unknown');

             if (photo && photo.startsWith('#')) {
                 style = `background-color: ${finalColor};`;
                 content = displayChar;
             } else if (photo && !photo.startsWith('#') && photo.length > 0) {
                 style = `background-image: url('${photo}');`;
                 content = '';
             } else {
                 style = `background-color: ${finalColor};`;
                 content = displayChar;
             }
             
             return `<div class="${sizeClass}" style="${style}">${content}</div>`;
        }
        
        function getChatDataByAt(at) {
            const allUsers = StorageManager.getAllUsers();
            const allChannels = StorageManager.getAllChannels();
            
            let target = allUsers.find(u => u.at === at);
            let type = 'user';
            
            if (!target) {
                target = allChannels.find(c => c.at === at);
                type = 'channel';
            }

            if (target) {
                const chatId = type === 'channel' ? target.id : target.id; 
                return { 
                    ...target, 
                    chatId: chatId, 
                    type: type,
                    id: target.id, 
                    status: target.status || (type === 'channel' ? `${target.subscribers?.length || 0} подписчиков` : 'Был(а) недавно')
                };
            }
            
            return null;
        }
        
        function formatTime(seconds) {
             const mins = Math.floor(seconds / 60);
             const secs = seconds % 60;
             return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        function formatMessageTime(timestamp) {
             const date = new Date(timestamp);
             const now = new Date();
             
             if (date.toDateString() === now.toDateString()) {
                 return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
             } else {
                 return date.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' });
             }
        }
        
        function formatDate(timestamp) {
             if (!timestamp) return 'Срок не установлен';
             const date = new Date(timestamp);
             return date.toLocaleDateString('ru-RU', { day: '2-digit', month: 'long', year: 'numeric' });
        }


        // --- ИНИЦИАЛИЗАЦИЯ И АУТЕНТИФИКАЦИЯ ---
        
        // Проверка и снятие истекших санкций
        function checkAndLiftSanctions(user) {
            const now = Date.now();
            let changed = false;

            if (user.isBlocked && user.blockUntil && now >= user.blockUntil) {
                user.isBlocked = false;
                user.blockUntil = null;
                changed = true;
            }

            if (user.isFrozen && user.freezeUntil && now >= user.freezeUntil) {
                user.isFrozen = false;
                user.freezeUntil = null;
                changed = true;
            }
            
            if (changed) {
                 let users = StorageManager.getAllUsers();
                 const index = users.findIndex(u => u.id === user.id);
                 if (index !== -1) users[index] = user;
                 StorageManager.saveAllUsers(users);
            }

            return user;
        }

        function initApp() {
            initStorageAndChannels(); 
            
            const currentAuthId = StorageManager.getCurrentAuthId();
            let allUsers = StorageManager.getAllUsers();
            
            if (currentAuthId) {
                let fullUser = allUsers.find(u => u.id === currentAuthId);
                
                if (fullUser) {
                    fullUser = checkAndLiftSanctions(fullUser);
                    
                    if (fullUser.isBlocked) {
                         showBlockedMessage(fullUser, 'block');
                         return;
                    }
                    if (fullUser.isFrozen) {
                         showBlockedMessage(fullUser, 'freeze');
                         return;
                    }
                    
                    handleAuthSuccess(fullUser);
                    return;
                }
            }
            
            document.getElementById('messenger-view').classList.add('hidden');
            document.getElementById('auth-view').classList.remove('hidden');
        }
        
        function initStorageAndChannels() {
             let users = StorageManager.getAllUsers();
             let channels = StorageManager.getAllChannels();

             const adminExists = users.some(u => u.id === CONST.ADMIN_USER_ID);
             if (!adminExists) {
                 const adminUser = {
                     id: CONST.ADMIN_USER_ID,
                     name: "Павел Дуров (Admin)",
                     at: "@durove",
                     email: "durove@gmail.com", 
                     password: "04092012", 
                     status: "Администратор",
                     role: "admin", 
                     photo: "#0088cc", 
                     isVerified: true, 
                     isBlocked: false,
                     blockUntil: null, 
                     isFrozen: false,
                     freezeUntil: null
                 };
                 users.push(adminUser);
             } else {
                 // Обновляем данные, если админ уже существует
                 const adminIndex = users.findIndex(u => u.id === CONST.ADMIN_USER_ID);
                 if (adminIndex !== -1) {
                      users[adminIndex].email = "durove@gmail.com";
                      users[adminIndex].password = "04092012";
                      users[adminIndex].at = "@durove";
                      users[adminIndex].isVerified = true;
                      users[adminIndex].blockUntil = users[adminIndex].blockUntil || null;
                      users[adminIndex].freezeUntil = users[adminIndex].freezeUntil || null;
                 }
             }
             
             // Гарантируем наличие новых полей для всех пользователей
             users = users.map(u => ({
                 ...u,
                 blockUntil: u.blockUntil || null,
                 freezeUntil: u.freezeUntil || null
             }));
             
             StorageManager.saveAllUsers(users);

             if (channels.length === 0) {
                 StorageManager.saveAllChannels([
                     { id: 2000, name: "Новости Чат-Аппа", at: "@app_news", ownerId: CONST.ADMIN_USER_ID, photo: '#007aff', isVerified: true, subscribers: [{ id: CONST.ADMIN_USER_ID, role: 'owner' }], admins: [CONST.ADMIN_USER_ID] },
                     { id: 2001, name: "Канал для Мемасов", at: "@memes_channel", ownerId: CONST.ADMIN_USER_ID, photo: '#e67e3c', isVerified: false, subscribers: [{ id: CONST.ADMIN_USER_ID, role: 'owner' }], admins: [CONST.ADMIN_USER_ID] }
                 ]);
             } else {
                 // Гарантируем, что у существующих каналов есть поле admins и поле role
                 channels = channels.map(c => {
                     const updatedChannel = {
                         ...c,
                         admins: c.admins || (c.ownerId ? [c.ownerId] : []),
                         subscribers: c.subscribers.map(sub => {
                             if (typeof sub === 'number') {
                                 // Если старый формат (только ID), определяем роль
                                 return { id: sub, role: sub === c.ownerId ? 'owner' : (c.admins && c.admins.includes(sub) ? 'admin' : 'subscriber') };
                             }
                             // Если уже новый формат, просто возвращаем
                             return sub;
                         })
                     };
                     
                     // Проверка, что владелец всегда есть в admins и role=owner
                     if (updatedChannel.ownerId && !updatedChannel.admins.includes(updatedChannel.ownerId)) {
                          updatedChannel.admins.push(updatedChannel.ownerId);
                     }
                     const ownerSubIndex = updatedChannel.subscribers.findIndex(s => s.id === updatedChannel.ownerId);
                     if (ownerSubIndex !== -1) {
                          updatedChannel.subscribers[ownerSubIndex].role = 'owner';
                     }
                     
                     return updatedChannel;
                 });
                 StorageManager.saveAllChannels(channels);
             }
        }

        function showBlockedMessage(user, type) {
            const isBlock = type === 'block';
            const untilTimestamp = isBlock ? user.blockUntil : user.freezeUntil;
            const status = isBlock ? 'заблокирован' : 'заморожен';
            const action = isBlock ? 'разблокировки' : 'разморозки';
            const dateStr = formatDate(untilTimestamp);
            
            const errorDiv = document.getElementById('error-message');
            errorDiv.innerHTML = `
                <h3 style="color: #e74c3c;">Упс, ваш аккаунт ${status}.</h3>
                <p>Ожидайте ${action}.</p>
                <p style="margin-top: 10px;"><strong>Срок:</strong> ${dateStr}</p>
            `;
            
            document.getElementById('auth-title').textContent = 'Вход в аккаунт';
            document.getElementById('auth-view').classList.remove('hidden');
            document.getElementById('messenger-view').classList.add('hidden');
            
            // Скрытие формы входа, если аккаунт заблокирован/заморожен
            document.getElementById('auth-form').classList.add('hidden');
            document.querySelector('.switch-link').classList.add('hidden');
            document.querySelector('.auth-card button:not(.reset-button)').classList.add('hidden'); // Скрываем кнопки
            
        }

        function switchAuthMode() {
            document.getElementById('auth-form').classList.remove('hidden');
            document.querySelector('.switch-link').classList.remove('hidden');
            document.querySelector('.auth-card button:not(.reset-button)').classList.remove('hidden');
            document.getElementById('error-message').innerHTML = '';

            AppState.isLoginMode = !AppState.isLoginMode;
            document.getElementById('auth-title').textContent = AppState.isLoginMode ? 'Вход в аккаунт' : 'Создание аккаунта';
            document.getElementById('auth-submit-btn').textContent = AppState.isLoginMode ? 'Войти' : 'Зарегистрироваться';
            document.querySelector('.switch-link').textContent = AppState.isLoginMode ? 'Нет аккаунта? Зарегистрироваться' : 'Уже есть аккаунт? Войти';
            
            document.getElementById('auth-name').classList.toggle('hidden', AppState.isLoginMode);
            document.getElementById('auth-email').placeholder = AppState.isLoginMode ? 'Username или Email' : 'Email';
            document.getElementById('auth-username').required = !AppState.isLoginMode;
        }

        function handleAuthSubmit(event) {
            event.preventDefault();
            const form = event.target;
            const data = new FormData(form);
            
            const name = data.get('name');
            const username = data.get('username');
            const email = data.get('email');
            const password = data.get('password');
            
            if (AppState.isLoginMode) {
                const loginId = data.get('email'); 
                loginUser(loginId, password);
            } else {
                registerUser(name, username, email, password);
            }
        }
        
        function registerUser(name, at, email, password) {
            let users = StorageManager.getAllUsers();
            document.getElementById('error-message').textContent = '';

            if (users.some(u => u.at === at)) {
                document.getElementById('error-message').textContent = 'Username уже занят.';
                return;
            }
            
            const newUser = {
                id: Date.now(),
                name: name,
                at: at,
                email: email,
                password: password,
                status: "Онлайн",
                role: "user",
                photo: generateAvatarColor(name), 
                isVerified: false,
                isBlocked: false,
                blockUntil: null, 
                isFrozen: false,
                freezeUntil: null
            };
            
            users.push(newUser);
            StorageManager.saveAllUsers(users);
            
            handleAuthSuccess(newUser, true);
        }

        function loginUser(loginId, password) {
            const users = StorageManager.getAllUsers();
            document.getElementById('error-message').textContent = '';

            let user = users.find(u => 
                (u.at === loginId || u.email === loginId) && u.password === password
            );

            if (!user) {
                document.getElementById('error-message').textContent = 'Неверный логин или пароль.';
                return;
            }
            
            user = checkAndLiftSanctions(user);

            if (user.isBlocked) {
                showBlockedMessage(user, 'block');
                return;
            }
            if (user.isFrozen) {
                showBlockedMessage(user, 'freeze');
                return;
            }
            
            handleAuthSuccess(user, true);
        }

        function handleAuthSuccess(user, shouldAddNewId = false) {
            stopPolling(); 
            AppState.currentUserId = user.id;
            AppState.currentUser = user;

            let authIds = StorageManager.getAuthUserIds();
            if (shouldAddNewId && !authIds.includes(user.id)) {
                authIds.push(user.id);
                StorageManager.saveAuthUserIds(authIds);
            }
            StorageManager.setCurrentAuthId(user.id);
            
            document.getElementById('auth-view').classList.add('hidden');
            document.getElementById('messenger-view').classList.remove('hidden');
            
            document.getElementById('auth-form').reset();
            
            document.getElementById('admin-menu-item').classList.toggle('hidden', user.role !== 'admin');

            document.getElementById('sidebar-profile-avatar').outerHTML = renderAvatar(user.photo, user.name, 'avatar');

            initUserFriends(); 
            
            const allChats = compileAllChatsForList();
            let firstChatId = null;
            let firstChatAt = null;
            
            if (allChats.length > 0) {
                 firstChatId = allChats[0].chatId;
                 firstChatAt = allChats[0].at;
            }

            startPolling();
            updateFriendsList(); 
            
            if (firstChatId) {
                showChat(firstChatId, firstChatAt);
            } else {
                document.getElementById('current-chat-name').textContent = 'Начните общение';
                document.getElementById('current-chat-status').textContent = 'Используйте поиск';
                document.getElementById('current-chat-avatar').outerHTML = renderAvatar('?', '?', 'chat-avatar-large');
                document.getElementById('messages-area').innerHTML = '<div style="text-align: center; color: var(--text-secondary); margin-top: 20px;"><i class="fas fa-comments" style="font-size: 3em; margin-bottom: 10px; color: var(--border-light);"></i><p>Начните новый чат или выберите канал.</p></div>';
            }
            
            document.getElementById('profile-view').classList.remove('active-view');
            document.getElementById('channel-settings-view').classList.remove('active-view');
            document.getElementById('admin-panel').classList.remove('active-view');
        }

        function switchAccount(userId) {
             if (AppState.currentUserId === userId) return;

             const allUsers = StorageManager.getAllUsers();
             let newAccount = allUsers.find(u => u.id === userId);
             
             if (newAccount) {
                 newAccount = checkAndLiftSanctions(newAccount);
                 
                 if (newAccount.isBlocked) {
                    return alert(`Аккаунт ${newAccount.at} заблокирован до ${formatDate(newAccount.blockUntil)}.`);
                 }
                 if (newAccount.isFrozen) {
                    return alert(`Аккаунт ${newAccount.at} заморожен до ${formatDate(newAccount.freezeUntil)}.`);
                 }

                 handleAuthSuccess(newAccount, false);
             } else {
                 alert('Ошибка: Аккаунт не найден.');
                 let authIds = StorageManager.getAuthUserIds().filter(id => id !== userId);
                 StorageManager.saveAuthUserIds(authIds);
                 updateAccountList();
             }
        }
        
        function addAccount() {
             AppState.currentUserId = null;
             AppState.currentUser = {};
             stopPolling();
             
             document.getElementById('messenger-view').classList.add('hidden');
             document.getElementById('auth-view').classList.remove('hidden');
             
             switchAuthMode(); 
        }
        
        function logout() {
            if (!confirm("Вы уверены, что хотите выйти из текущего аккаунта?")) return;
            
            stopPolling();
            
            let authIds = StorageManager.getAuthUserIds();
            authIds = authIds.filter(id => id !== AppState.currentUserId);
            StorageManager.saveAuthUserIds(authIds);

            if (authIds.length > 0) {
                const newCurrentId = authIds[0];
                const allUsers = StorageManager.getAllUsers();
                let newAccount = allUsers.find(u => u.id === newCurrentId);
                
                if (newAccount) {
                    newAccount = checkAndLiftSanctions(newAccount);
                    if (newAccount.isBlocked || newAccount.isFrozen) {
                        // Если первый доступный аккаунт заблокирован, просто выходим
                        StorageManager.remove(CONST.CURRENT_AUTH_ID_KEY);
                        document.location.reload(); 
                        return;
                    }
                    handleAuthSuccess(newAccount, false);
                    return;
                }
            } 
            
            StorageManager.remove(CONST.CURRENT_AUTH_ID_KEY);
            AppState.currentUserId = null;
            document.location.reload(); 
        }
        
        function resetAllData() {
             if (confirm("ВНИМАНИЕ! Вы уверены, что хотите сбросить ВСЕ данные (пользователи, чаты, каналы)? Это действие необратимо.")) {
                 localStorage.clear();
                 document.location.reload();
             }
        }
        
        // --- НОВЫЕ ФУНКЦИИ ДЛЯ АДМИН-ВХОДА ---

        function showAdminLoginModal() {
             document.getElementById('admin-login-modal').classList.remove('hidden');
             document.getElementById('admin-login-password').value = '';
             document.getElementById('admin-login-error').textContent = '';
             document.getElementById('admin-login-password').focus();
        }

        function hideAdminLoginModal() {
             document.getElementById('admin-login-modal').classList.add('hidden');
        }

        function attemptAdminLogin() {
             const inputPassword = document.getElementById('admin-login-password').value;
             const errorDiv = document.getElementById('admin-login-error');
             errorDiv.textContent = '';

             const users = StorageManager.getAllUsers();
             const adminUser = users.find(u => u.id === CONST.ADMIN_USER_ID);

             if (!adminUser) {
                 errorDiv.textContent = 'Ошибка: Админ-аккаунт не найден.';
                 return;
             }

             if (inputPassword === adminUser.password) {
                 hideAdminLoginModal();
                 handleAuthSuccess(adminUser, true); 
             } else {
                 errorDiv.textContent = 'Неверный пароль.';
             }
        }
        
        // --- ЧАТЫ И СООБЩЕНИЯ ---
        
        function initUserFriends() {
             let friends = StorageManager.getUserFriends(AppState.currentUserId);
             const allChannels = StorageManager.getAllChannels();
             
             friends = friends.filter(f => f.at && f.at.startsWith('@') && !allChannels.some(c => c.at === f.at));

             StorageManager.saveUserFriends(friends, AppState.currentUserId);
        }
        
        function compileAllChatsForList() {
            let allChats = [];
            let friendsRaw = StorageManager.getUserFriends(AppState.currentUserId);
            let subscriptionsRaw = StorageManager.getChannelSubscriptions(AppState.currentUserId);
            let allUsers = StorageManager.getAllUsers();
            let allChannels = StorageManager.getAllChannels();

            // 1. Добавление чатов с пользователями (Friends)
            friendsRaw.forEach(f => {
                const targetUser = allUsers.find(u => u.at === f.at);
                if (!targetUser) return; 

                const fullData = { 
                    ...targetUser, 
                    chatId: f.chatId, 
                    type: 'user', 
                    status: targetUser.status || 'Был(а) недавно'
                };
                
                const messages = StorageManager.getUserMessages(AppState.currentUserId)[f.chatId] || [];
                const lastMessageObj = messages[messages.length - 1];
                let lastMessageText = f.lastMessage || 'Начать чат...';
                let lastMessageTime = '';

                if (lastMessageObj) {
                    if (lastMessageObj.type === 'voice') lastMessageText = '🎤 Голосовое сообщение';
                    else if (lastMessageObj.type === 'image') lastMessageText = '🖼️ Фото';
                    else {
                        const senderName = lastMessageObj.sender === AppState.currentUser.name ? 'Я' : lastMessageObj.sender.split(' ')[0];
                        lastMessageText = `${senderName}: ${lastMessageObj.text.substring(0, 40)}${lastMessageObj.text.length > 40 ? '...' : ''}`;
                    }
                    lastMessageTime = formatMessageTime(lastMessageObj.id);
                }

                allChats.push({
                    ...fullData,
                    unreadCount: f.unreadCount || 0,
                    lastMessage: lastMessageText,
                    lastMessageTime: lastMessageTime,
                    lastActivityId: lastMessageObj ? lastMessageObj.id : 0 
                });
            });

            // 2. Добавление каналов (Subscriptions + Owned Channels)
            allChannels.forEach(c => {
                 const isSubscribed = c.subscribers.some(sub => sub.id === AppState.currentUserId);
                 const isOwner = c.ownerId === AppState.currentUserId;
                 
                 if (!isSubscribed && !isOwner) return;

                 const fullData = { 
                     ...c, 
                     chatId: c.id, 
                     type: 'channel', 
                     status: `${c.subscribers?.length || 0} подписчиков` 
                 };

                 const channelSubData = subscriptionsRaw.find(s => s.chatId === c.id) || { lastMessage: 'Вы подписаны.', unreadCount: 0 };
                 const messages = StorageManager.getChannelMessages(c.id);
                 const lastMessageObj = messages[messages.length - 1];
                 let lastMessageText = channelSubData.lastMessage;
                 let lastMessageTime = '';
                 
                 if (lastMessageObj) {
                     const senderName = lastMessageObj.sender === AppState.currentUser.name ? 'Я' : lastMessageObj.sender.split(' ')[0];
                     if (lastMessageObj.type === 'voice') lastMessageText = `${senderName}: 🎤`;
                     else if (lastMessageObj.type === 'image') lastMessageText = `${senderName}: 🖼️`;
                     else lastMessageText = `${senderName}: ${lastMessageObj.text.substring(0, 40)}${lastMessageObj.text.length > 40 ? '...' : ''}`;
                     lastMessageTime = formatMessageTime(lastMessageObj.id);
                 }

                 allChats.push({
                     ...fullData,
                     unreadCount: channelSubData.unreadCount || 0,
                     lastMessage: lastMessageText,
                     lastMessageTime: lastMessageTime,
                     lastActivityId: lastMessageObj ? lastMessageObj.id : 0
                 });
            });
            
            allChats.sort((a, b) => {
                 if (a.unreadCount > 0 && b.unreadCount === 0) return -1;
                 if (a.unreadCount === 0 && b.unreadCount > 0) return 1;
                 return (b.lastActivityId || 0) - (a.lastActivityId || 0); 
            });
            
            return allChats;
        }

        function updateFriendsList() {
            const chatListContainer = document.getElementById('chats-list-container');
            chatListContainer.innerHTML = '';
            
            const allChats = compileAllChatsForList();

            allChats.forEach(chat => {
                const isChannel = chat.type === 'channel';
                
                const chatItem = document.createElement('div');
                chatItem.className = `chat-item ${AppState.currentChatId == chat.chatId ? 'active' : ''}`; 
                chatItem.setAttribute('data-chat-id', chat.chatId);
                chatItem.setAttribute('data-chat-at', chat.at); 
                chatItem.onclick = () => showChat(chat.chatId, chat.at);

                const avatarHtml = renderAvatar(chat.photo, chat.name);

                chatItem.innerHTML = `
                    ${avatarHtml}
                    <div class="info">
                        <div class="name">
                            ${chat.name}
                            ${isChannel ? '<span class="channel-badge">Канал</span>' : ''}
                            ${chat.isVerified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}
                        </div>
                        <div class="last-message">${chat.lastMessage}</div>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: flex-end; justify-content: center; height: 100%;">
                        <div class="time">${chat.lastMessageTime}</div>
                        ${chat.unreadCount > 0 ? `<div class="new-message-badge" style="margin-top: 5px;">${chat.unreadCount}</div>` : ''}
                    </div>
                `;
                chatListContainer.appendChild(chatItem);
            });
        }
        
        // НОВАЯ ПРОВЕРКА РОЛЕЙ В КАНАЛЕ
        function getChannelRole(channel, userId) {
            if (channel.ownerId === userId) return 'owner';
            if (channel.admins && channel.admins.includes(userId)) return 'admin';
            const subscriber = channel.subscribers.find(sub => sub.id === userId);
            return subscriber ? subscriber.role : 'none';
        }

        function canUserPublish(channel, userId) {
            const role = getChannelRole(channel, userId);
            return role === 'owner' || role === 'admin';
        }

        function showChat(chatId, chatAt) {
            
            if (AppState.currentChatId == chatId) {
                 return;
            }
            
            AppState.currentChatId = chatId;
            cancelReply(); 

            const friend = getChatDataByAt(chatAt);
            AppState.currentChatData = friend; 
            
            if (friend) {
                const isChannel = friend.type === 'channel';
                const chatName = friend.name || friend.at.replace('@', 'Контакт');
                
                document.getElementById('current-chat-name').innerHTML = `${chatName} ${friend.isVerified ? '<i class="fas fa-check-circle verified-badge" style="font-size: 1.1em;"></i>' : ''}`;
                document.getElementById('current-chat-status').textContent = friend.status;
                document.getElementById('current-chat-avatar').outerHTML = renderAvatar(friend.photo, chatName, 'chat-avatar-large');
                
                document.getElementById('channel-subscribe-btn').classList.toggle('hidden', !isChannel || friend.ownerId === AppState.currentUserId);
                document.getElementById('channel-settings-icon').classList.toggle('hidden', !isChannel || friend.ownerId !== AppState.currentUserId);
                
                const inputArea = document.getElementById('chat-input-area');
                
                if (isChannel) {
                    const isOwner = friend.ownerId === AppState.currentUserId;
                    const canPublish = canUserPublish(friend, AppState.currentUserId);
                    const isSubscribed = friend.subscribers.some(sub => sub.id === AppState.currentUserId);
                    
                    document.getElementById('channel-subscribe-btn').textContent = isSubscribed ? 'Отписаться' : 'Подписаться';
                    document.getElementById('channel-subscribe-btn').onclick = () => toggleChannelSubscription(chatId);
                    
                    // Поле ввода видно, только если это владелец или админ канала
                    inputArea.classList.toggle('hidden', !canPublish);
                    
                    if (canPublish) {
                         document.getElementById('message-input').placeholder = 'Написать в канал...';
                    } else if (isSubscribed) {
                         document.getElementById('message-input').placeholder = 'Вы можете только читать этот канал.';
                    } else {
                         document.getElementById('message-input').placeholder = 'Подпишитесь, чтобы читать.';
                    }
                    
                } else {
                     inputArea.classList.remove('hidden');
                     document.getElementById('message-input').placeholder = 'Написать сообщение...';
                     document.getElementById('channel-settings-icon').classList.add('hidden');
                }
                
                let targetList = isChannel ? StorageManager.getChannelSubscriptions(AppState.currentUserId) : StorageManager.getUserFriends(AppState.currentUserId);
                
                const targetIndex = targetList.findIndex(f => f.chatId == chatId);
                let shouldUpdateFriendsList = false;
                
                if (targetIndex !== -1 && targetList[targetIndex].unreadCount > 0) {
                    targetList[targetIndex].unreadCount = 0; 
                    if (isChannel) StorageManager.saveChannelSubscriptions(targetList, AppState.currentUserId); 
                    else StorageManager.saveUserFriends(targetList, AppState.currentUserId);
                    shouldUpdateFriendsList = true;
                }
                
                document.querySelectorAll('.chat-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.getAttribute('data-chat-id') == chatId) item.classList.add('active');
                });
                
                if (shouldUpdateFriendsList) updateFriendsList();
                
                renderMessages(chatId);
            }
        }
        
        // --- ПРОФИЛЬ И НАСТРОЙКИ ---
        
        function updateAccountList() {
            const list = document.getElementById('account-list');
            list.innerHTML = '';
            
            const authIds = StorageManager.getAuthUserIds();
            let allUsers = StorageManager.getAllUsers();
            
            authIds.forEach(id => {
                let user = allUsers.find(u => u.id === id);
                if (!user) return;
                
                user = checkAndLiftSanctions(user); // Проверяем и обновляем статус
                
                const isCurrent = user.id === AppState.currentUserId;
                const isSanctioned = user.isBlocked || user.isFrozen;
                
                const item = document.createElement('li');
                item.className = `menu-item ${isCurrent ? 'current-user' : ''}`;
                item.onclick = isSanctioned ? () => alert(`Аккаунт ${user.isBlocked ? 'заблокирован' : 'заморожен'} до ${formatDate(user.isBlocked ? user.blockUntil : user.freezeUntil)}.`) : () => switchAccount(user.id);
                
                let statusIcon = isSanctioned ? '<i class="fas fa-lock" style="color: #e74c3c;"></i>' : 
                                 isCurrent ? '<i class="fas fa-check" style="color: var(--color-brand);"></i>' : 
                                 '<i class="fas fa-arrow-right" style="color: var(--text-secondary); opacity: 0.5;"></i>';
                
                let statusText = isSanctioned ? `<div class="at" style="color: #e74c3c;">${user.isBlocked ? 'БЛОКИРОВКА' : 'ЗАМОРОЖЕН'}</div>` : 
                                 `<div class="at">${user.at}</div>`;

                item.innerHTML = `
                    ${renderAvatar(user.photo, user.name)}
                    <div class="account-info">
                        <div class="name">
                            ${user.name}
                            ${user.isVerified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}
                        </div>
                        ${statusText}
                    </div>
                    ${statusIcon}
                `;
                list.appendChild(item);
            });
        }
        
        function showProfile(toggle = true) {
            document.getElementById('channel-settings-view').classList.remove('active-view');
            document.getElementById('admin-panel').classList.remove('active-view');

            document.getElementById('profile-name-display').innerHTML = `${AppState.currentUser.name} ${AppState.currentUser.isVerified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}`;
            document.getElementById('profile-at-display').textContent = AppState.currentUser.at;
            
            document.getElementById('profile-name-input').value = AppState.currentUser.name;
            document.getElementById('profile-username-input').value = AppState.currentUser.at;
            document.getElementById('profile-status-input').value = AppState.currentUser.status;
            document.getElementById('profile-photo-input').value = AppState.currentUser.photo;
            
            document.getElementById('profile-avatar-display').outerHTML = renderAvatar(AppState.currentUser.photo, AppState.currentUser.name, 'profile-avatar-large');
            
            document.getElementById('admin-menu-item').classList.toggle('hidden', AppState.currentUser.role !== 'admin');
            
            updateAccountList();

            if (toggle) {
                document.getElementById('profile-view').classList.toggle('active-view');
            } else {
                 document.getElementById('profile-view').classList.remove('active-view');
            }
            
            document.getElementById('edit-profile-area').classList.add('hidden');
        }
        
        function hideProfile() {
             document.getElementById('profile-view').classList.remove('active-view');
             if (AppState.currentChatId && AppState.currentChatData) {
                 showChat(AppState.currentChatId, AppState.currentChatData.at);
             }
        }

        function toggleEditProfile() {
             document.getElementById('edit-profile-area').classList.toggle('hidden');
        }
        
        function updateProfile() {
            const newName = document.getElementById('profile-name-input').value.trim();
            const newAt = document.getElementById('profile-username-input').value.trim();
            const newStatus = document.getElementById('profile-status-input').value.trim();
            const newPhoto = document.getElementById('profile-photo-input').value.trim();
            
            const oldUser = AppState.currentUser;
            
            let users = StorageManager.getAllUsers();
            if (users.some(u => u.at === newAt && u.id !== oldUser.id)) {
                 alert('Этот Username уже занят.');
                 return;
            }

            AppState.currentUser = {
                 ...oldUser,
                 name: newName,
                 at: newAt,
                 status: newStatus,
                 photo: newPhoto.startsWith('#') || newPhoto.length > 0 ? newPhoto : generateAvatarColor(newName)
            };
            
            const index = users.findIndex(u => u.id === oldUser.id);
            if (index !== -1) {
                 users[index] = AppState.currentUser;
                 StorageManager.saveAllUsers(users);
                 StorageManager.setCurrentAuthId(AppState.currentUser.id); 
                 updateMessagesHash(true); 
            }
            
            alert('Профиль обновлен.');
            showProfile(false); 
            document.getElementById('sidebar-profile-avatar').outerHTML = renderAvatar(AppState.currentUser.photo, AppState.currentUser.name, 'avatar');
            updateFriendsList();
            if (AppState.currentChatId && AppState.currentChatData) {
                 showChat(AppState.currentChatId, AppState.currentChatData.at);
            }

        }
        
        // --- НАСТРОЙКИ КАНАЛА ---
        
        function showChannelSettings() {
             if (!AppState.currentChatData || AppState.currentChatData.type !== 'channel' || AppState.currentChatData.ownerId !== AppState.currentUserId) {
                 return alert('Это не ваш канал или канал не выбран.');
             }
             
             document.getElementById('profile-view').classList.remove('active-view');
             document.getElementById('admin-panel').classList.remove('active-view');

             const channel = AppState.currentChatData;
             
             document.getElementById('channel-settings-name').innerHTML = `${channel.name} ${channel.isVerified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}`;
             document.getElementById('channel-settings-at').textContent = channel.at;
             document.getElementById('channel-settings-avatar').outerHTML = renderAvatar(channel.photo, channel.name, 'profile-avatar-large');
             
             document.getElementById('channel-settings-name-input').value = channel.name;
             document.getElementById('channel-settings-at-input').value = channel.at;
             document.getElementById('channel-settings-photo-input').value = channel.photo;
             
             document.getElementById('channel-settings-view').classList.add('active-view');
        }
        
        function hideChannelSettings() {
             document.getElementById('channel-settings-view').classList.remove('active-view');
             if (AppState.currentChatId && AppState.currentChatData) {
                 showChat(AppState.currentChatId, AppState.currentChatData.at);
             }
        }
        
        function updateChannelSettings(event) {
             event.preventDefault();
             if (!AppState.currentChatData || AppState.currentChatData.type !== 'channel') return;

             const newName = document.getElementById('channel-settings-name-input').value.trim();
             const newAt = document.getElementById('channel-settings-at-input').value.trim();
             const newPhoto = document.getElementById('channel-photo-input').value.trim();
             
             let allChannels = StorageManager.getAllChannels();
             const currentChannel = AppState.currentChatData;

             if (allChannels.some(c => c.at === newAt && c.id !== currentChannel.id)) {
                  alert('Этот Username уже занят.');
                  return;
             }
             
             const channelIndex = allChannels.findIndex(c => c.id === currentChannel.id);
             
             if (channelIndex !== -1) {
                 allChannels[channelIndex] = {
                     ...currentChannel,
                     name: newName,
                     at: newAt,
                     photo: newPhoto.startsWith('#') || newPhoto.length > 0 ? newPhoto : generateAvatarColor(newName)
                 };
                 StorageManager.saveAllChannels(allChannels);
                 
                 AppState.currentChatData = allChannels[channelIndex];
                 
                 // Обновление подписок (в списке друзей)
                 StorageManager.getAllUsers().forEach(user => {
                     let subs = StorageManager.getChannelSubscriptions(user.id);
                     const subIndex = subs.findIndex(s => s.chatId === currentChannel.id);
                     if (subIndex !== -1) {
                         subs[subIndex].at = newAt;
                         StorageManager.saveChannelSubscriptions(subs, user.id);
                     }
                 });
                 
                 alert('Настройки канала сохранены.');
                 updateMessagesHash(true);
                 updateFriendsList();
                 hideChannelSettings();
             }
        }

        function deleteChannel() {
             if (!AppState.currentChatData || AppState.currentChatData.type !== 'channel') return;

             if (confirm(`Вы уверены, что хотите безвозвратно удалить канал "${AppState.currentChatData.name}"?`)) {
                 let allChannels = StorageManager.getAllChannels();
                 allChannels = allChannels.filter(c => c.id !== AppState.currentChatData.id);
                 StorageManager.saveAllChannels(allChannels);
                 
                 StorageManager.getAllUsers().forEach(user => {
                     let subs = StorageManager.getChannelSubscriptions(user.id);
                     subs = subs.filter(s => s.chatId !== AppState.currentChatData.id);
                     StorageManager.saveChannelSubscriptions(subs, user.id);
                 });
                 
                 StorageManager.remove(CONST.CHANNEL_MESSAGES_PREFIX + AppState.currentChatData.id);

                 alert('Канал удален.');
                 AppState.currentChatId = null;
                 AppState.currentChatData = null;
                 
                 updateMessagesHash(true);
                 updateFriendsList();
                 hideChannelSettings();
             }
        }
        
        // --- ОТПРАВКА СООБЩЕНИЙ ---
        
        function renderMessages(chatId) {
            const messagesArea = document.getElementById('messages-area');
            messagesArea.innerHTML = '';
            
            const friend = AppState.currentChatData;
            if (!friend) return;

            const isChannel = friend.type === 'channel';

            let messages;
            if (isChannel) {
                messages = StorageManager.getChannelMessages(friend.id);
            } else {
                messages = StorageManager.getUserMessages(AppState.currentUserId)[chatId] || [];
            }
            
            messages.forEach(msg => {
                const isSent = msg.sender === AppState.currentUser.name;
                
                const messageBubble = document.createElement('div');
                messageBubble.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
                messageBubble.setAttribute('data-message-id', msg.id);
                
                if (!isChannel) {
                     messageBubble.oncontextmenu = (e) => showContextMenu(e, msg.id, msg.sender, msg.text);
                }

                let content = '';

                if (isChannel && !isSent) {
                    const senderUser = StorageManager.getAllUsers().find(u => u.name === msg.sender);
                    const senderColor = senderUser ? senderUser.photo : generateAvatarColor(msg.sender);

                    content += `<strong style="font-size: 0.9em; display: block; margin-bottom: 5px; color: ${senderColor};">${msg.sender}</strong>`;
                }

                if (msg.replyTo) {
                    const replyToMsg = messages.find(m => m.id === msg.replyTo);
                    if (replyToMsg) {
                        const replySenderName = replyToMsg.sender === AppState.currentUser.name ? 'Я' : replyToMsg.sender.split(' ')[0];
                        content += `
                            <div class="reply-to-content ${isSent ? 'sent' : 'received'}" onclick="scrollToMessage(${msg.replyTo})">
                                <span class="reply-sender" style="color: ${isSent ? '#ffffffaa' : 'var(--color-brand)'};">${replySenderName}</span>
                                <span style="display: block; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; font-size: 0.85em;">${replyToMsg.text || '...'}</span>
                            </div>
                        `;
                    }
                }

                if (msg.type === 'voice') {
                    content += `
                        <div class="voice-message-container">
                             <button onclick="playVoice('${msg.voiceUrl}')" style="background-color: ${isSent ? 'white' : 'var(--color-brand)'};">
                                 <i class="fas fa-play" id="play-icon-${msg.id}"></i>
                             </button>
                             <span>${formatTime(msg.voiceDuration)}</span>
                        </div>
                    `;
                    messageBubble.style.padding = '10px 14px 10px 10px';
                } else if (msg.type === 'image') {
                    content += `
                        <img src="${msg.photoUrl}" style="max-width: 100%; border-radius: 10px; margin-bottom: 5px;" onclick="alert('Просмотр фото...')">
                        <p style="font-size: 0.9em;">${msg.text || ''}</p>
                    `;
                    messageBubble.style.padding = '5px';
                } else {
                    content += msg.text;
                }
                
                content += `<span class="time-stamp">${formatMessageTime(msg.id)}</span>`;

                messageBubble.innerHTML += content;
                messagesArea.appendChild(messageBubble);
            });
            
            scrollToBottom();
        }
        
        function playVoice(url) {
             const audio = new Audio(url);
             audio.play();
             alert(`Воспроизведение симуляции: ${url}`);
        }

        function generateVoiceUrl() {
             const baseUrl = 'https://example.com/voice/';
             const randomId = Math.random().toString(36).substring(2, 8);
             return `${baseUrl}${randomId}.mp3`;
        }

        function sendMessage(isVoice = false, duration = 0) {
            const messageInput = document.getElementById('message-input');
            const messageText = messageInput.value.trim();
            
            if (!AppState.currentChatId || !AppState.currentChatData) return alert('Сначала выберите чат!'); 

            const friend = AppState.currentChatData;
            const isChannel = friend.type === 'channel';
            
            // НОВАЯ ПРОВЕРКА ПРАВ
            if (isChannel && !canUserPublish(friend, AppState.currentUserId)) {
                 return alert('Вы не являетесь владельцем или администратором этого канала.'); 
            }

            let messageType = 'text';
            let photoUrl = null;
            let voiceDuration = null;
            let voiceUrl = null;

            if (isVoice) {
                 messageType = 'voice';
                 voiceDuration = duration;
                 voiceUrl = generateVoiceUrl(); 
            } else if (AppState.currentImagePreview) {
                 messageType = 'image';
                 photoUrl = AppState.currentImagePreview;
            } else if (messageText === '') {
                 return;
            }
            
            document.getElementById('send-voice-icon').className = 'fas fa-microphone'; 
            
            const newMessage = {
                id: Date.now() + Math.floor(Math.random() * 1000), 
                sender: AppState.currentUser.name,
                text: messageText,
                type: messageType,
                replyTo: AppState.replyMessageData ? AppState.replyMessageData.id : null,
                photoUrl: photoUrl,
                voiceDuration: voiceDuration,
                voiceUrl: voiceUrl,
                isRead: true 
            };
            
            if (isChannel) {
                let channelMessages = StorageManager.getChannelMessages(friend.id);
                channelMessages.push(newMessage);
                StorageManager.saveChannelMessages(channelMessages, friend.id);
                
                // Уведомление всех подписчиков, кроме отправителя
                friend.subscribers.forEach(sub => {
                    if (sub.id !== AppState.currentUserId) updateUnreadCount(friend.at, 1, sub.id);
                });

            } else {
                let messageData = StorageManager.getUserMessages(AppState.currentUserId);
                messageData[AppState.currentChatId] = messageData[AppState.currentChatId] || [];
                messageData[AppState.currentChatId].push(newMessage);
                StorageManager.saveUserMessages(messageData, AppState.currentUserId);
                
                const friendUser = StorageManager.getAllUsers().find(u => u.id === friend.id);
                if (friendUser) {
                    addMessageToFriendChat(friendUser.id, AppState.currentUser.at, AppState.currentUser.name, newMessage, messageType);
                }
            }
            
            messageInput.value = '';
            cancelReply();
            resetImagePreview();
            updateLastMessageAndUnread();
            updateFriendsList();
            renderMessages(AppState.currentChatId); 
            updateMessagesHash(true); 
        }

        function updateLastMessageAndUnread(userId = AppState.currentUserId) {
            let friendsList = StorageManager.getUserFriends(userId);
            let subscriptions = StorageManager.getChannelSubscriptions(userId);
            
            if (!AppState.currentChatData) return;
            
            const friend = AppState.currentChatData;
            
            let targetList = friend.type === 'channel' ? subscriptions : friendsList;
            let targetIndex = targetList.findIndex(f => f.chatId == AppState.currentChatId);
            
            if (targetIndex !== -1) {
                 
                 let messages;
                 if (friend.type === 'channel') {
                     messages = StorageManager.getChannelMessages(friend.id);
                 } else {
                     messages = StorageManager.getUserMessages(userId)[AppState.currentChatId] || [];
                 }
                 
                 const lastMsg = messages[messages.length - 1];
                 if (lastMsg) {
                      targetList[targetIndex].lastMessage = lastMsg.text || (lastMsg.type === 'voice' ? '🎤' : '🖼️');
                 }
                 
                 if (friend.type === 'channel') StorageManager.saveChannelSubscriptions(targetList, userId); 
                 else StorageManager.saveUserFriends(targetList, userId);
            }
        }
        
        // --- БИНДИНГ СОБЫТИЙ ---
        
        document.getElementById('auth-form').addEventListener('submit', handleAuthSubmit);
        document.getElementById('profile-form').addEventListener('submit', function(event) {
             event.preventDefault();
             updateProfile();
        });
        document.getElementById('channel-settings-form').addEventListener('submit', updateChannelSettings);

        document.addEventListener('DOMContentLoaded', initApp);
        
        // --- ДРУГИЕ ФУНКЦИИ (без изменений) ---

        function scrollToBottom() {
            const messagesArea = document.getElementById('messages-area');
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function getMessagesHash() {
            if (!AppState.currentUserId) return '';
            let hash = (localStorage.getItem(CONST.USERS_STORAGE_KEY) || '').length.toString();
            hash += (localStorage.getItem(CONST.FRIENDS_PREFIX + AppState.currentUserId) || '').length.toString();
            hash += (localStorage.getItem(CONST.CHANNEL_SUBS_PREFIX + AppState.currentUserId) || '').length.toString();
            hash += (localStorage.getItem(CONST.CHANNELS_STORAGE_KEY) || '').length.toString();

            if (AppState.currentChatId && AppState.currentChatData) {
                if (AppState.currentChatData.type === 'channel') {
                     hash += (localStorage.getItem(CONST.CHANNEL_MESSAGES_PREFIX + AppState.currentChatData.id) || '').length.toString();
                } else {
                     hash += (localStorage.getItem(CONST.CHAT_MESSAGES_PREFIX + AppState.currentUserId) || '').length.toString();
                }
            }
            return hash; 
        }

        function startPolling() {
            if (AppState.pollingInterval) clearInterval(AppState.pollingInterval);
            AppState.lastKnownMessagesHash = getMessagesHash(); 

            AppState.pollingInterval = setInterval(() => {
                if (!AppState.currentUserId) return stopPolling();

                const currentHash = getMessagesHash();
                if (currentHash !== AppState.lastKnownMessagesHash) {
                    AppState.lastKnownMessagesHash = currentHash;
                    updateFriendsList(); 
                    if (AppState.currentChatId) renderMessages(AppState.currentChatId);
                } 
            }, 3000); 
        }

        function stopPolling() {
            if (AppState.pollingInterval) {
                clearInterval(AppState.pollingInterval);
                AppState.pollingInterval = null;
            }
        }
        
        function updateMessagesHash(forceReset = false) {
             if (forceReset) {
                 AppState.lastKnownMessagesHash = ''; 
             }
        }
        
        function handleMessageKey(event) {
             if (event.key === 'Enter') {
                 if (document.getElementById('message-input').value.trim() === '' && !AppState.currentImagePreview) {
                     toggleVoiceRecording();
                 } else {
                     sendMessage();
                 }
             } else {
                 const input = document.getElementById('message-input').value.trim();
                 const icon = document.getElementById('send-voice-icon');
                 icon.className = (input !== '' || AppState.currentImagePreview) ? 'fas fa-paper-plane' : 'fas fa-microphone';
             }
        }
        
        function handleSendOrVoice() {
             const input = document.getElementById('message-input').value.trim();
             if (input !== '' || AppState.currentImagePreview) {
                 sendMessage();
             } else {
                 toggleVoiceRecording();
             }
        }
        
        function addMessageToFriendChat(friendId, myAt, senderName, message, type = 'text') {
             const allUsers = StorageManager.getAllUsers();
             const friend = allUsers.find(u => u.id === friendId);
             
             if (!friend) return; 
             
             const friendFriends = StorageManager.getUserFriends(friend.id);
             const myChatDataAsFriend = friendFriends.find(f => f.at === myAt);

             if (myChatDataAsFriend) {
                 const friendChatId = myChatDataAsFriend.chatId;
                 
                 let friendMessages = StorageManager.getUserMessages(friend.id);
                 friendMessages[friendChatId] = friendMessages[friendChatId] || [];
                 
                 const newMsg = {
                     ...message,
                     sender: senderName,
                     isRead: false 
                 };
                 
                 friendMessages[friendChatId].push(newMsg);
                 StorageManager.saveUserMessages(friendMessages, friend.id);
                 
                 updateUnreadCount(myChatDataAsFriend.at, 1, friend.id);
             } 
             updateMessagesHash(true); 
        }
        
        function updateUnreadCount(friendAt, delta, userId) {
            let friends = StorageManager.getUserFriends(userId);
            let subscriptions = StorageManager.getChannelSubscriptions(userId);
            
            let targetList;
            
            const friendInFriends = friends.find(f => f.at === friendAt);
            const friendInSubs = subscriptions.find(f => f.at === friendAt);
            
            if (friendInFriends) targetList = friends;
            else if (friendInSubs) targetList = subscriptions;
            else return;

            const friendIndex = targetList.findIndex(f => f.at === friendAt);

            if (friendIndex !== -1) {
                targetList[friendIndex].unreadCount = (targetList[friendIndex].unreadCount || 0) + delta;
                targetList[friendIndex].unreadCount = Math.max(0, targetList[friendIndex].unreadCount); 
                updateLastMessageAndUnread(userId); 
                if (friendInSubs) StorageManager.saveChannelSubscriptions(targetList, userId);
                else StorageManager.saveUserFriends(targetList, userId);
                updateMessagesHash(true);
            }
        }
        
        function startVoiceRecording() {
             AppState.isRecording = true;
             document.getElementById('voice-recording-modal').classList.remove('hidden');
             document.getElementById('recording-timer').textContent = '00:00';
             document.getElementById('voice-permissions-warning').classList.remove('hidden');
             document.getElementById('recording-actions').classList.add('hidden');

             setTimeout(() => {
                 document.getElementById('voice-permissions-warning').classList.add('hidden');
                 document.getElementById('recording-actions').classList.remove('hidden');
                 AppState.voiceDuration = 0;
                 AppState.voiceRecordingTimer = setInterval(() => {
                     AppState.voiceDuration++;
                     document.getElementById('recording-timer').textContent = formatTime(AppState.voiceDuration);
                     if (AppState.voiceDuration >= 30) stopVoiceRecording(false); 
                 }, 1000);
             }, 1000); 
        }

        function stopVoiceRecording(shouldSend) {
             clearInterval(AppState.voiceRecordingTimer);
             AppState.isRecording = false;
             document.getElementById('voice-recording-modal').classList.add('hidden');
             
             if (shouldSend && AppState.voiceDuration > 0) {
                 if (AppState.voiceDuration < 1) {
                     alert('Голосовое сообщение слишком короткое.');
                 } else {
                     sendMessage(true, AppState.voiceDuration);
                 }
             }
             
             AppState.voiceDuration = 0;
        }

        function toggleVoiceRecording() {
             if (!AppState.currentChatId) return alert('Выберите чат для записи.');
             const friend = AppState.currentChatData;
             const isChannel = friend && friend.type === 'channel';
             
             if (isChannel && !canUserPublish(friend, AppState.currentUserId)) {
                 return alert('Вы не можете писать голосовые сообщения в этот канал.');
             }

             if (AppState.isRecording) {
                 stopVoiceRecording(false); 
             } else {
                 startVoiceRecording();
             }
        }
        
        function previewImage(event) {
             const file = event.target.files[0];
             if (!file) return resetImagePreview();

             const reader = new FileReader();
             reader.onload = function(e) {
                 AppState.currentImagePreview = e.target.result;
                 document.getElementById('message-input').value = '🖼️ Добавьте подпись...';
                 document.getElementById('message-input').focus();
                 document.getElementById('send-voice-icon').className = 'fas fa-paper-plane';
             };
             reader.readAsDataURL(file);
        }

        function resetImagePreview() {
             AppState.currentImagePreview = null;
             document.getElementById('image-upload-input').value = null;
             document.getElementById('message-input').value = '';
             document.getElementById('send-voice-icon').className = 'fas fa-microphone';
        }
        
        function showContextMenu(event, messageId, sender, text) {
            event.preventDefault();
            const menu = document.getElementById('context-menu');
            AppState.selectedMessageElement = { id: messageId, sender, text };
            
            menu.style.top = `${event.clientY}px`;
            menu.style.left = `${event.clientX}px`;
            menu.classList.remove('hidden');

            document.addEventListener('click', hideContextMenu, { once: true });
        }

        function hideContextMenu() {
            document.getElementById('context-menu').classList.add('hidden');
            AppState.selectedMessageElement = null;
        }

        function replyToSelectedMessage() {
            if (!AppState.selectedMessageElement) return;

            AppState.replyMessageData = AppState.selectedMessageElement;
            const senderName = AppState.replyMessageData.sender === AppState.currentUser.name ? 'Я' : AppState.replyMessageData.sender;
            document.getElementById('reply-preview-sender').textContent = senderName + ':';
            document.getElementById('reply-preview-text').textContent = AppState.replyMessageData.text.substring(0, 50);
            document.getElementById('reply-preview').classList.remove('hidden');
            document.getElementById('message-input').focus();
            
            hideContextMenu();
        }

        function cancelReply() {
            AppState.replyMessageData = null;
            document.getElementById('reply-preview').classList.add('hidden');
        }

        function scrollToMessage(messageId) {
             const target = document.querySelector(`.message-bubble[data-message-id="${messageId}"]`);
             if (target) {
                 document.getElementById('messages-area').scrollTop = target.offsetTop - 50;
                 target.style.outline = '2px solid var(--color-brand)';
                 target.style.boxShadow = '0 0 10px rgba(83, 163, 245, 0.5)';
                 setTimeout(() => {
                      target.style.outline = 'none';
                      target.style.boxShadow = 'none';
                 }, 1500);
             }
        }
        
        function showSearchModal() {
            document.getElementById('search-modal').classList.remove('hidden');
            document.getElementById('search-user-input').focus();
        }

        function hideSearchModal() {
            document.getElementById('search-modal').classList.add('hidden');
            document.getElementById('search-result').innerHTML = '';
            document.getElementById('search-user-input').value = '';
        }

        function handleSearchKey(event) {
            if (event.key === 'Enter' && document.getElementById('search-friend-input').value.trim().length > 0) {
                 showSearchModal();
                 document.getElementById('search-user-input').value = document.getElementById('search-friend-input').value.trim();
                 document.getElementById('search-friend-input').value = '';
                 performSearch();
            }
        }
        
        function startChatWithUser(at) {
             if (!AppState.currentUserId) return;
             
             const target = getChatDataByAt(at);
             if (!target) {
                 alert('Пользователь/Канал не найден.');
                 return;
             }
             
             if (target.type === 'channel') {
                 toggleChannelSubscription(target.id);
                 const subscriptions = StorageManager.getChannelSubscriptions(AppState.currentUserId);
                 const existingSub = subscriptions.find(s => s.at === at);
                 if(existingSub) showChat(existingSub.chatId, existingSub.at);
                 hideSearchModal();
                 return;
             }
             
             if (target.id === AppState.currentUserId) return alert('Вы не можете начать чат с самим собой через поиск. Используйте заметки!');

             let friends = StorageManager.getUserFriends(AppState.currentUserId);
             let existingChat = friends.find(f => f.at === at);
             
             if (!existingChat) {
                 const newChatId = Date.now(); 
                 friends.push({ chatId: newChatId, at: at, unreadCount: 0, lastMessage: 'Начать чат...' });
                 StorageManager.saveUserFriends(friends, AppState.currentUserId);
                 
                 const friendUser = StorageManager.getAllUsers().find(u => u.id === target.id);
                 if (friendUser) {
                    let friendFriends = StorageManager.getUserFriends(target.id);
                    if (!friendFriends.some(f => f.at === AppState.currentUser.at)) {
                         friendFriends.push({ chatId: newChatId, at: AppState.currentUser.at, unreadCount: 0, lastMessage: 'Новый контакт.' });
                         StorageManager.saveUserFriends(friendFriends, target.id);
                    }
                 }

                 updateFriendsList();
                 showChat(newChatId, at);
             } else {
                 showChat(existingChat.chatId, at);
             }
             hideSearchModal();
        }

        function toggleChannelSubscription(channelId) {
             let subscriptions = StorageManager.getChannelSubscriptions(AppState.currentUserId);
             let allChannels = StorageManager.getAllChannels();
             let channel = allChannels.find(c => c.id === channelId);
             
             if (!channel) return;
             
             const isSubscribed = subscriptions.some(s => s.chatId === channelId);
             
             if (isSubscribed) {
                 subscriptions = subscriptions.filter(s => s.chatId !== channelId);
                 channel.subscribers = channel.subscribers.filter(sub => sub.id !== AppState.currentUserId);
                 channel.admins = channel.admins.filter(id => id !== AppState.currentUserId);
                 alert(`Вы отписались от ${channel.name}.`);
             } else {
                 subscriptions.push({ chatId: channelId, at: channel.at, unreadCount: 0, lastMessage: 'Вы подписались.' });
                 channel.subscribers.push({ id: AppState.currentUserId, role: 'subscriber' });
                 alert(`Вы подписались на ${channel.name}!`);
             }
             
             StorageManager.saveChannelSubscriptions(subscriptions, AppState.currentUserId);
             StorageManager.saveAllChannels(allChannels);
             
             updateMessagesHash(true); 
             updateFriendsList();
             
             if (!document.getElementById('search-modal').classList.contains('hidden')) performSearch();
             if (AppState.currentChatId === channelId) showChat(channelId, channel.at);
        }

        function performSearch() {
            let query = document.getElementById('search-user-input').value.trim();
            const resultDiv = document.getElementById('search-result');
            resultDiv.innerHTML = 'Идет поиск...';

            if (!query) {
                 resultDiv.innerHTML = `<p style="color: #e74c3c;">Ошибка: Введите @username пользователя или канала.</p>`;
                 return;
            }
            
            if (!query.startsWith('@')) {
                 query = '@' + query;
            }

            query = query.toLowerCase();

            const allUsers = StorageManager.getAllUsers().filter(u => u.id !== AppState.currentUserId);
            const userMatch = allUsers.find(u => u.at.toLowerCase() === query);
            const channelMatch = StorageManager.getAllChannels().find(c => c.at.toLowerCase() === query);
            
            const target = userMatch || channelMatch;

            if (target) {
                 const isChannel = !!channelMatch;
                 const isSubscribed = isChannel ? target.subscribers.some(sub => sub.id === AppState.currentUserId) : false;
                 
                 resultDiv.innerHTML = `
                     <div class="chat-item" style="border: none; background: none; padding: 10px 0;">
                         ${renderAvatar(target.photo, target.name)}
                         <div class="info">
                             <div class="name">
                                 ${target.name}
                                 ${isChannel ? '<span class="channel-badge">Канал</span>' : ''}
                                 ${target.isVerified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}
                             </div>
                             <div style="color: var(--text-secondary);">${target.at}</div>
                         </div>
                         <button onclick="startChatWithUser('${target.at}')" style="background-color: ${isChannel && isSubscribed ? '#e74c3c' : 'var(--color-brand)'}">
                            ${isChannel ? (isSubscribed ? 'Отписаться' : 'Подписаться') : 'Начать чат'}
                         </button>
                     </div>
                 `;
            } else {
                 resultDiv.innerHTML = `<p style="color: var(--text-secondary);">Пользователь или канал "${query}" не найден.</p>`;
            }
        }
        
        function showAdminPanel() {
             if (AppState.currentUser.role !== 'admin') return alert('У вас нет прав администратора.');
             document.getElementById('profile-view').classList.remove('active-view');
             document.getElementById('channel-settings-view').classList.remove('active-view');
             document.getElementById('admin-panel').classList.add('active-view');
             updateAdminChannelList(); 
        }

        function hideAdminPanel() {
             document.getElementById('admin-panel').classList.remove('active-view');
             showProfile(false); 
        }

        function adminSearchVerify() {
             const query = document.getElementById('admin-verify-input').value.trim();
             const resultDiv = document.getElementById('admin-verify-result');
             resultDiv.innerHTML = '';
             
             if (!query || !query.startsWith('@')) {
                 resultDiv.innerHTML = '<p>Введите корректный @username.</p>';
                 return;
             }

             const allUsers = StorageManager.getAllUsers();
             const allChannels = StorageManager.getAllChannels();
             
             let target = allUsers.find(u => u.at === query);
             let type = 'Пользователь';
             
             if (!target) {
                 target = allChannels.find(c => c.at === query);
                 type = 'Канал';
             }

             AppState.adminTargetVerify = target;

             if (target) {
                 const t = target;
                 resultDiv.innerHTML = `
                     <div class="admin-action-item">
                         <p><strong>${type}:</strong> ${t.name} (${t.at})</p>
                         <p style="margin-bottom: 10px;"><strong>Статус:</strong> ${t.isVerified ? '<span style="color: var(--color-brand);">Верифицирован</span>' : 'Не верифицирован'}</p>
                         <button style="background-color: ${t.isVerified ? '#e74c3c' : 'var(--color-accent)'}; padding: 8px 12px; border-radius: 6px;" onclick="adminVerifyAction()">
                             ${t.isVerified ? 'Снять Галочку' : 'Поставить Галочку'}
                         </button>
                     </div>
                 `;
             } else {
                 resultDiv.innerHTML = '<p>Пользователь или Канал не найден.</p>';
             }
        }
        
        function adminVerifyAction() {
            if (!AppState.adminTargetVerify) return;

            const target = AppState.adminTargetVerify;
            const isUser = target.hasOwnProperty('email');

            target.isVerified = !target.isVerified;
            
            if (isUser) {
                let users = StorageManager.getAllUsers();
                const index = users.findIndex(u => u.id === target.id);
                if (index !== -1) users[index] = target;
                StorageManager.saveAllUsers(users);
            } else {
                let channels = StorageManager.getAllChannels();
                const index = channels.findIndex(c => c.id === target.id);
                if (index !== -1) channels[index] = target;
                StorageManager.saveAllChannels(channels);
            }

            alert(`${target.name} теперь ${target.isVerified ? 'верифицирован' : 'не верифицирован'}.`);
            AppState.adminTargetVerify = target; 
            adminSearchVerify(); 
            updateMessagesHash(true);
        }

        function adminSearchUser() {
             const query = document.getElementById('admin-search-user-input').value.trim();
             const resultDiv = document.getElementById('admin-search-result');
             resultDiv.innerHTML = '';
             
             if (!query || !query.startsWith('@')) {
                 resultDiv.innerHTML = '<p>Введите корректный @username.</p>';
                 return;
             }

             let allUsers = StorageManager.getAllUsers().filter(u => u.role !== 'admin');
             let targetUser = allUsers.find(u => u.at === query);
             
             if(targetUser) {
                 targetUser = checkAndLiftSanctions(targetUser); // Проверяем статус при поиске
             }
             
             AppState.adminTargetUser = targetUser;

             if (AppState.adminTargetUser) {
                 const u = AppState.adminTargetUser;
                 const blockStatus = u.isBlocked ? `<span style="color: #e74c3c;">Заблокирован (до ${formatDate(u.blockUntil)})</span>` : 'Активен';
                 const freezeStatus = u.isFrozen ? `<span style="color: #e67e22;">Заморожен (до ${formatDate(u.freezeUntil)})</span>` : 'Активен';
                 
                 resultDiv.innerHTML = `
                     <div class="admin-action-item">
                         <p><strong>Имя:</strong> ${u.name} (${u.at})</p>
                         <p><strong>Блокировка:</strong> ${blockStatus}</p>
                         <p style="margin-bottom: 10px;"><strong>Заморозка:</strong> ${freezeStatus}</p>
                         <p style="margin-bottom: 10px;"><strong>Верифицирован:</strong> ${u.isVerified ? 'Да' : 'Нет'}</p>
                         <div style="margin-top: 10px; display: flex; gap: 10px;">
                             <button style="background-color: ${u.isBlocked ? '#3498db' : '#e74c3c'}; padding: 8px 12px; border-radius: 6px;" onclick="showAdminTimeModal('${u.isBlocked ? 'unblock' : 'block'}')">
                                 ${u.isBlocked ? 'Разблокировать' : 'Заблокировать'}
                             </button>
                             <button style="background-color: ${u.isFrozen ? '#3498db' : '#e67e22'}; padding: 8px 12px; border-radius: 6px;" onclick="showAdminTimeModal('${u.isFrozen ? 'unfreeze' : 'freeze'}')">
                                 ${u.isFrozen ? 'Разморозить' : 'Заморозить'}
                             </button>
                             <button style="background-color: #95a5a6; padding: 8px 12px; border-radius: 6px;" onclick="adminAction('delete')">Удалить</button>
                         </div>
                     </div>
                 `;
             } else {
                 resultDiv.innerHTML = '<p>Пользователь не найден (или это админ).</p>';
             }
        }
        
        // Показ модального окна для установки срока
        function showAdminTimeModal(actionType) {
            if (!AppState.adminTargetUser) return;
            
            AppState.adminCurrentActionType = actionType;
            const user = AppState.adminTargetUser;
            const modal = document.getElementById('admin-time-modal');
            const durationInput = document.getElementById('admin-duration-input');
            durationInput.value = '';
            
            if (actionType.startsWith('un')) {
                // Если разблокировка/разморозка, срок не нужен
                executeAdminTimedAction(0); // 0 дней = немедленное снятие
                return;
            }
            
            document.getElementById('admin-time-title').textContent = actionType === 'block' ? 'Срок Блокировки' : 'Срок Заморозки';
            document.getElementById('admin-time-text').textContent = `Введите количество дней для ${user.at}:`;
            
            modal.classList.remove('hidden');
            durationInput.focus();
        }
        
        function hideAdminTimeModal() {
             document.getElementById('admin-time-modal').classList.add('hidden');
        }

        // Выполнение действия с учетом срока
        function executeAdminTimedAction(durationDays = null) {
            if (!AppState.adminTargetUser) return;
            const user = AppState.adminTargetUser;
            const actionType = AppState.adminCurrentActionType;
            const durationInput = document.getElementById('admin-duration-input');

            if (durationDays === null) {
                 durationDays = parseInt(durationInput.value, 10);
                 if (isNaN(durationDays) || durationDays <= 0 || durationDays > 365) {
                     document.getElementById('admin-time-error').textContent = 'Введите срок от 1 до 365 дней.';
                     return;
                 }
                 hideAdminTimeModal();
            }

            let users = StorageManager.getAllUsers();
            const index = users.findIndex(u => u.id === user.id);
            if (index === -1) return;

            const u = users[index];
            const now = Date.now();
            const untilTimestamp = durationDays > 0 ? now + durationDays * 24 * 60 * 60 * 1000 : null;

            switch (actionType) {
                case 'block':
                    u.isBlocked = true;
                    u.blockUntil = untilTimestamp;
                    u.isFrozen = false; 
                    u.freezeUntil = null;
                    alert(`Пользователь ${u.at} заблокирован до ${formatDate(untilTimestamp)}.`);
                    break;
                case 'unblock':
                    u.isBlocked = false;
                    u.blockUntil = null;
                    alert(`Пользователь ${u.at} разблокирован.`);
                    break;
                case 'freeze':
                    u.isFrozen = true;
                    u.freezeUntil = untilTimestamp;
                    u.isBlocked = false; 
                    u.blockUntil = null;
                    alert(`Пользователь ${u.at} заморожен до ${formatDate(untilTimestamp)}.`);
                    break;
                case 'unfreeze':
                    u.isFrozen = false;
                    u.freezeUntil = null;
                    alert(`Пользователь ${u.at} разморожен.`);
                    break;
            }

            StorageManager.saveAllUsers(users);
            AppState.adminTargetUser = u; 
            adminSearchUser(); 
            updateMessagesHash(true); 
        }

        function adminAction(action) {
             if (!AppState.adminTargetUser) return;

             let users = StorageManager.getAllUsers();
             const index = users.findIndex(u => u.id === AppState.adminTargetUser.id);
             if (index === -1) return;

             const u = users[index];

             if (action === 'delete') {
                 if (!confirm(`Вы уверены, что хотите удалить пользователя ${u.at}?`)) return;
                 users.splice(index, 1);
                 alert(`Пользователь ${u.at} удален.`);
                 AppState.adminTargetUser = null; 
             }

             StorageManager.saveAllUsers(users);
             adminSearchUser(); 
             updateMessagesHash(true); 
        }

        function updateAdminChannelList() {
             const channelsDiv = document.getElementById('admin-channel-list');
             const allChannels = StorageManager.getAllChannels();
             channelsDiv.innerHTML = '';
             document.getElementById('admin-channel-count').textContent = allChannels.length;

             allChannels.forEach(c => {
                 const owner = StorageManager.getAllUsers().find(u => u.id === c.ownerId)?.at || '@unknown';
                 channelsDiv.innerHTML += `
                     <div style="border: 1px solid var(--border-light); padding: 10px; border-radius: 6px; margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between;">
                         <span><strong>${c.name}</strong> (${c.at}) - Владелец: ${owner} - ${c.isVerified ? '✅' : '❌'}</span>
                         <button style="background-color: #e74c3c; padding: 5px 10px; border-radius: 6px;" onclick="adminChannelAction(${c.id}, 'delete')">Удалить</button>
                     </div>
                 `;
             });
        }

        function adminChannelAction(channelId, action) {
             let channels = StorageManager.getAllChannels();
             const index = channels.findIndex(c => c.id === channelId);
             if (index === -1) return;

             if (action === 'delete') {
                 const channelName = channels[index].name;
                 channels.splice(index, 1);
                 StorageManager.saveAllChannels(channels);
                 alert(`Канал "${channelName}" удален.`);
             }
             
             updateAdminChannelList();
             updateMessagesHash(true);
        }

        function showCreateChannelModal() {
             document.getElementById('create-channel-modal').classList.remove('hidden');
        }

        function hideCreateChannelModal() {
             document.getElementById('create-channel-modal').classList.add('hidden');
        }
        
        function validateChannelAt() {
             const input = document.getElementById('channel-at-input');
             let value = input.value.startsWith('@') ? input.value.substring(1) : input.value;
             value = value.replace(/[^a-zA-Z0-9_]/g, '');
             input.value = '@' + value;
        }

        function createChannel() {
             const name = document.getElementById('channel-name-input').value.trim();
             const at = document.getElementById('channel-at-input').value.trim();
             const photo = document.getElementById('channel-photo-input').value.trim();
             const errorDiv = document.getElementById('channel-error-message');
             errorDiv.textContent = '';

             if (!name || at.length < 6 || !at.startsWith('@')) {
                 errorDiv.textContent = 'Некорректно заполнены поля.';
                 return;
             }
             
             let channels = StorageManager.getAllChannels();
             if (channels.some(c => c.at === at)) {
                 errorDiv.textContent = 'Канал с таким username уже существует.';
                 return;
             }
             
             const currentUserId = AppState.currentUserId;

             const newChannel = {
                 id: Date.now(),
                 name: name,
                 at: at,
                 ownerId: currentUserId, 
                 photo: photo || generateAvatarColor(name),
                 isVerified: false,
                 // Владелец сразу является единственным подписчиком и админом
                 subscribers: [{ id: currentUserId, role: 'owner' }],
                 admins: [currentUserId],
                 type: 'channel'
             };

             channels.push(newChannel);
             StorageManager.saveAllChannels(channels);
             hideCreateChannelModal();
             updateMessagesHash(true);
             
             // Добавляем канал в подписки текущего пользователя
             let subscriptions = StorageManager.getChannelSubscriptions(currentUserId);
             subscriptions.push({ chatId: newChannel.id, at: newChannel.at, unreadCount: 0, lastMessage: 'Вы создали канал.' });
             StorageManager.saveChannelSubscriptions(subscriptions, currentUserId);
             
             updateFriendsList();
             alert(`Канал ${name} создан! Вы являетесь его владельцем.`);
             
        }
        
        // --- НОВЫЙ ФУНКЦИОНАЛ: УПРАВЛЕНИЕ ПОДПИСЧИКАМИ КАНАЛА ---

        function showSubscribersModal() {
            if (!AppState.currentChatData || AppState.currentChatData.type !== 'channel' || AppState.currentChatData.ownerId !== AppState.currentUserId) {
                return;
            }
            document.getElementById('subscribers-modal').classList.remove('hidden');
            renderSubscribersList();
        }

        function hideSubscribersModal() {
            document.getElementById('subscribers-modal').classList.add('hidden');
        }

        function renderSubscribersList() {
            const channel = AppState.currentChatData;
            const listContainer = document.getElementById('subscribers-list-container');
            listContainer.innerHTML = '';
            
            const allUsers = StorageManager.getAllUsers();
            
            // Сортировка: Владелец -> Админы -> Подписчики
            const sortedSubscribers = channel.subscribers.sort((a, b) => {
                const roleA = a.role;
                const roleB = b.role;
                
                if (roleA === 'owner') return -1;
                if (roleB === 'owner') return 1;
                if (roleA === 'admin' && roleB !== 'admin') return -1;
                if (roleB === 'admin' && roleA !== 'admin') return 1;
                return 0; // subscriber
            });

            sortedSubscribers.forEach(sub => {
                const user = allUsers.find(u => u.id === sub.id);
                if (!user) return;
                
                const isOwner = sub.id === channel.ownerId;
                const isCurrentAdmin = sub.role === 'admin';
                const buttonText = isCurrentAdmin ? 'Снять Админа' : 'Назначить Админом';
                const buttonColor = isCurrentAdmin ? '#e67e22' : '#34c759';
                
                const item = document.createElement('div');
                item.className = 'subscriber-item';
                
                let roleBadge = '';
                if (sub.role === 'owner') roleBadge = '<span class="subscriber-role-badge" style="background-color: var(--color-brand);">Владелец</span>';
                if (sub.role === 'admin') roleBadge = '<span class="subscriber-role-badge">Админ</span>';
                
                item.innerHTML = `
                    <div class="subscriber-info">
                        ${renderAvatar(user.photo, user.name)}
                        <div>
                            <div class="name">${user.name} ${user.isVerified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}</div>
                            <div style="font-size: 0.8em; color: var(--text-secondary);">${user.at} ${roleBadge}</div>
                        </div>
                    </div>
                    <div class="subscriber-actions">
                        ${!isOwner ? `
                           <button style="background-color: ${buttonColor};" onclick="toggleChannelAdminRole(${channel.id}, ${sub.id}, ${isCurrentAdmin})">
                               ${buttonText}
                           </button>` 
                           : ''}
                    </div>
                `;
                
                listContainer.appendChild(item);
            });
        }

        function toggleChannelAdminRole(channelId, userId, isCurrentlyAdmin) {
            let allChannels = StorageManager.getAllChannels();
            let channelIndex = allChannels.findIndex(c => c.id === channelId);
            
            if (channelIndex === -1 || allChannels[channelIndex].ownerId !== AppState.currentUserId) return;
            
            let channel = allChannels[channelIndex];
            const user = StorageManager.getUserById(userId);
            if (!user) return;

            if (isCurrentlyAdmin) {
                // Снять админа
                channel.admins = channel.admins.filter(id => id !== userId);
                const subIndex = channel.subscribers.findIndex(sub => sub.id === userId);
                if (subIndex !== -1) channel.subscribers[subIndex].role = 'subscriber';
                alert(`${user.name} больше не администратор канала.`);
            } else {
                // Назначить админом
                if (!channel.admins.includes(userId)) channel.admins.push(userId);
                const subIndex = channel.subscribers.findIndex(sub => sub.id === userId);
                if (subIndex !== -1) channel.subscribers[subIndex].role = 'admin';
                alert(`${user.name} назначен администратором канала.`);
            }

            StorageManager.saveAllChannels(allChannels);
            AppState.currentChatData = channel; 
            
            renderSubscribersList(); // Обновляем список
            updateMessagesHash(true); 
            if (AppState.currentChatId === channelId) showChat(channelId, channel.at); // Обновляем вид чата
        }
        
    </script>
</body>
</html>